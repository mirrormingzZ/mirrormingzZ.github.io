<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[GitLab持续集成持续部署]]></title>
    <url>%2F2018%2F11%2F19%2FGitLab%2F</url>
    <content type="text"><![CDATA[持续集成的基本概念互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称CI）。 持续集成持续集成指的是，频繁地（一天多次）将代码集成到主干。它的好处主要有两个： 快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。 防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。 Martin Fowler 说过，”持续集成并不能消除 Bug，而是让它们非常容易发现和改正。” 持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。 与持续集成相关的，还有两个概念，分别是持续交付和持续部署。 持续交付持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。 持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。 持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（production-like environments）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。 持续部署持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。 持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。 持续部署的前提是能自动化完成测试、构建、部署等步骤。 持续集成的操作流程根据持续集成的设计，代码从提交到生产，整个过程有以下几步。 提交流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交（commit）。 测试（第一轮）代码仓库对 commit 操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。 测试的种类： 单元测试：针对函数或模块的测试 集成测试：针对整体产品的某个功能的测试，又称功能测试 端对端测试：从用户界面直达数据库的全链路测试 第一轮至少要跑单元测试。 构建通过第一轮测试，代码就可以合并进主干，就算可以交付了。 交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。 常用的构建工具如下： Jenkins Travis Codeship Strider Jenkins 和 Strider 是开源软件，Travis 和 Codeship 对于开源项目可以免费使用。它们都会将构建和测试，在一次运行中执行完成。 测试（第二轮）构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。 第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。 需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。 部署通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。 生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接（symlink）指向这个目录，然后重新启动应用。这方面的部署工具有Ansible，Chef，Puppet等。 回滚一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。 使用 GitLab 持续集成简介从 GitLab 8.0 开始，GitLab CI 就已经集成在 GitLab 中，我们只要在项目中添加一个 .gitlab-ci.yml 文件，然后添加一个 Runner，即可进行持续集成。 而且随着 GitLab 的升级，GitLab CI 变得越来越强大。 概念Pipeline一次 Pipeline 其实相当于一次构建任务，里面可以包含多个流程，如安装依赖、运行测试、编译、部署测试服务器、部署生产服务器等流程。 任何提交或者 Merge Request 的合并都可以触发 Pipeline，如下图所示： 12345+------------------+ +----------------+| | trigger | || Commit / MR +----------&gt;+ Pipeline || | | |+------------------+ +----------------+ StagesStages 表示构建阶段，说白了就是上面提到的流程。我们可以在一次 Pipeline 中定义多个 Stages，这些 Stages 会有以下特点： 所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始 只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功 如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败 因此，Stages 和 Pipeline 的关系就是： 123456789+--------------------------------------------------------+| || Pipeline || || +-----------+ +------------+ +------------+ || | Stage 1 |----&gt;| Stage 2 |-----&gt;| Stage 3 | || +-----------+ +------------+ +------------+ || |+--------------------------------------------------------+ JobsJobs 表示构建工作，表示某个 Stage 里面执行的工作。我们可以在 Stages 里面定义多个 Jobs，这些 Jobs 会有以下特点： 相同 Stage 中的 Jobs 会并行执行 相同 Stage 中的 Jobs 都执行成功时，该 Stage 才会成功 如果任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 失败 所以，Jobs 和 Stage 的关系图就是： 123456789+------------------------------------------+| || Stage 1 || || +---------+ +---------+ +---------+ || | Job 1 | | Job 2 | | Job 3 | || +---------+ +---------+ +---------+ || |+------------------------------------------+ 使用 GitLab Runner简介理解了上面的基本概念之后，有没有觉得少了些什么东西 —— 由谁来执行这些构建任务呢？答案就是 GitLab Runner 了！ 想问为什么不是 GitLab CI 来运行那些构建任务？ 一般来说，构建任务都会占用很多的系统资源 (譬如编译代码)，而 GitLab CI 又是 GitLab 的一部分，如果由 GitLab CI 来运行构建任务的话，在执行构建任务的时候，GitLab 的性能会大幅下降。 GitLab CI 最大的作用是管理各个项目的构建状态，因此，运行构建任务这种浪费资源的事情就交给 GitLab Runner 来做拉！ 因为 GitLab Runner 可以安装到不同的机器上，所以在构建任务运行期间并不会影响到 GitLab 的性能 安装 在目标主机上安装 GitLab Runner，这里的目标主机指你要部署的服务器 Ubuntu 安装脚本： 123curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.deb.sh | sudo bashsudo apt-get updatesudo apt-get install gitlab-ci-multi-runner 注册 Runner安装好 GitLab Runner 之后，我们只要启动 Runner 然后和 GitLab CI 绑定： 12345678910111213141516171819[root@iZbp1fmnx8oyubksjdk7leZ gitbook]# gitlab-ci-multi-runner registerRunning in system-mode. Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):http://192.168.75.146:8080/Please enter the gitlab-ci token for this runner:1Lxq_f1NRfCfeNbE5WRhPlease enter the gitlab-ci description for this runner:[iZbp1fmnx8oyubksjdk7leZ]: deploy-gamingPlease enter the gitlab-ci tags for this runner (comma separated):deployWhether to run untagged builds [true/false]:[false]: trueWhether to lock Runner to current project [true/false]:[false]: Registering runner... succeeded runner=P_zfkhTbPlease enter the executor: virtualbox, docker+machine, parallels, shell, ssh, docker-ssh+machine, kubernetes, docker, docker-ssh:shellRunner registered successfully. Feel free to start it, but if it&apos;s running already the config should be automatically reloaded! 说明： gitlab-ci-multi-runner register：执行注册命令 Please enter the gitlab-ci coordinator URL：输入 ci 地址 Please enter the gitlab-ci token for this runner：输入 ci token Please enter the gitlab-ci description for this runner：输入 runner 名称 Please enter the gitlab-ci tags for this runner：设置 tag Whether to run untagged builds：这里选择 true ，代码上传后会能够直接执行 Whether to lock Runner to current project：直接回车，不用输入任何口令 Please enter the executor：选择 runner 类型，这里我们选择的是 shell CI 的地址和令牌，在 项目 –&gt; 设置 –&gt; CI/CD –&gt; Runner 设置： .gitlab-ci.yml在项目工程下编写 .gitlab-ci.yml 配置文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758stages: - install_deps - test - build - deploy_test - deploy_productioncache: key: $&#123;CI_BUILD_REF_NAME&#125; paths: - node_modules/ - dist/# 安装依赖install_deps: stage: install_deps only: - develop - master script: - npm install# 运行测试用例test: stage: test only: - develop - master script: - npm run test# 编译build: stage: build only: - develop - master script: - npm run clean - npm run build:client - npm run build:server# 部署测试服务器deploy_test: stage: deploy_test only: - develop script: - pm2 delete app || true - pm2 start app.js --name app# 部署生产服务器deploy_production: stage: deploy_production only: - master script: - bash scripts/deploy/deploy.sh 上面的配置把一次 Pipeline 分成五个阶段： 安装依赖(install_deps) 运行测试(test) 编译(build) 部署测试服务器(deploy_test) 部署生产服务器(deploy_production) 设置 Job.only 后，只有当 develop 分支和 master 分支有提交的时候才会触发相关的 Jobs。 节点说明： stages：定义构建阶段，这里只有一个阶段 deploy deploy：构建阶段 deploy 的详细配置也就是任务配置 script：需要执行的 shell 脚本 only：这里的 master 指在提交到 master 时执行 tags：与注册 runner 时的 tag 匹配 其它配置为保证能够正常集成，我们还需要一些其它配置： 安装完 GitLab Runner 后系统会增加一个 gitlab-runner 账户，我们将它加进 root 组： 1gpasswd -a gitlab-runner root 配置需要操作目录的权限，比如你的 runner 要在 gaming 目录下操作： 1chmod 775 gaming 由于我们的 shell 脚本中有执行 git pull 的命令，我们直接设置以 ssh 方式拉取代码： 12345su gitlab-runnerssh-keygen -t rsa -C &quot;你在 GitLab 上的邮箱地址&quot;cd cd .sshcat id_rsa.pub 复制 id_rsa.pub 中的秘钥到 GitLab： 通过 ssh 的方式将代码拉取到本地 测试集成效果所有操作完成后 push 代码到服务器，查看是否成功： passed 表示执行成功 其他命令删除注册信息： 1gitlab-ci-multi-runner unregister --name &quot;名称&quot; 查看注册列表： 1gitlab-ci-multi-runner list 使用 GitLab Runner Docker为了配置方便，我们使用 docker 来部署 GitLab Runner 环境准备 创建工作目录 /usr/local/docker/runner 创建构建目录 /usr/local/docker/runner/environment 下载 jdk-8u152-linux-x64.tar.gz 并复制到 /usr/local/docker/runner/environment Dockerfile在 /usr/local/docker/runner/environment 目录下创建 Dockerfile 12345678910111213141516171819202122232425262728293031323334353637383940414243444546FROM gitlab/gitlab-runner:v11.1.0MAINTAINER mirror &lt;mirrorming@qq.com&gt;# 修改软件源RUN echo &apos;deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse&apos; &gt; /etc/apt/sources.list &amp;&amp; \ echo &apos;deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse&apos; &gt;&gt; /etc/apt/sources.list &amp;&amp; \ echo &apos;deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse&apos; &gt;&gt; /etc/apt/sources.list &amp;&amp; \ echo &apos;deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse&apos; &gt;&gt; /etc/apt/sources.list &amp;&amp; \ apt-get update -y &amp;&amp; \ apt-get clean# 安装 DockerRUN apt-get -y install apt-transport-https ca-certificates curl software-properties-common &amp;&amp; \ curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add - &amp;&amp; \ add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; &amp;&amp; \ apt-get update -y &amp;&amp; \ apt-get install -y docker-ceCOPY daemon.json /etc/docker/daemon.json# 安装 Docker ComposeWORKDIR /usr/local/binRUN wget https://raw.githubusercontent.com/topsale/resources/master/docker/docker-composeRUN chmod +x docker-compose# 安装 JavaRUN mkdir -p /usr/local/javaWORKDIR /usr/local/javaCOPY jdk-8u152-linux-x64.tar.gz /usr/local/javaRUN tar -zxvf jdk-8u152-linux-x64.tar.gz &amp;&amp; \ rm -fr jdk-8u152-linux-x64.tar.gz# 安装 MavenRUN mkdir -p /usr/local/mavenWORKDIR /usr/local/mavenRUN wget https://raw.githubusercontent.com/topsale/resources/master/maven/apache-maven-3.5.3-bin.tar.gz# COPY apache-maven-3.5.3-bin.tar.gz /usr/local/mavenRUN tar -zxvf apache-maven-3.5.3-bin.tar.gz &amp;&amp; \ rm -fr apache-maven-3.5.3-bin.tar.gz# COPY settings.xml /usr/local/maven/apache-maven-3.5.3/conf/settings.xml# 配置环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_152ENV MAVEN_HOME /usr/local/maven/apache-maven-3.5.3ENV PATH $PATH:$JAVA_HOME/bin:$MAVEN_HOME/binWORKDIR / daemon.json在 /usr/local/docker/runner/environment 目录下创建 daemon.json，用于配置加速器和仓库地址 12345678&#123; &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot; ], &quot;insecure-registries&quot;: [ &quot;192.168.75.131:5000&quot; ]&#125; docker-compose.yml在 /usr/local/docker/runner 目录下创建 docker-compose.yml 12345678910version: &apos;3.1&apos;services: gitlab-runner: build: environment restart: always container_name: gitlab-runner privileged: true volumes: - /usr/local/docker/runner/config:/etc/gitlab-runner - /var/run/docker.sock:/var/run/docker.sock 注册 Runner123456789101112131415161718192021222324252627282930(!每一个项目都要配置)docker exec -it gitlab-runner gitlab-runner register# 输入 GitLab 地址Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):http://192.168.72.144:8082# 输入 GitLab TokenPlease enter the gitlab-ci token for this runner:KoJsLbPETZzU9jyVuX26# 输入 Runner 的说明Please enter the gitlab-ci description for this runner:可以为空# 设置 Tag，可以用于指定在构建规定的 tag 时触发 ciPlease enter the gitlab-ci tags for this runner (comma separated):deploy(可以为空)# 这里选择 true ，可以用于代码上传后直接执行Whether to run untagged builds [true/false]:true# 这里选择 false，可以直接回车，默认为 false(更新后版本没有)Whether to lock Runner to current project [true/false]:false# 选择 runner 执行器，这里我们选择的是 shellPlease enter the executor: virtualbox, docker+machine, parallels, shell, ssh, docker-ssh+machine, kubernetes, docker, docker-ssh:shell 附：项目配置 Dockerfile 案例1234567891011121314FROM openjdk:8-jreMAINTAINER mirror &lt;mirrorming@qq.com&gt;RUN wget http://www.mirrorming.cn:8888/group1/M00/00/00/rBAbeFwAmeSAWwAkAC3dfxJ69A84094.gz \ &amp;&amp; mv rBAbeFwAmeSAWwAkAC3dfxJ69A84094.gz dockerize.tar.gz \ &amp;&amp; tar -C /usr/local/bin -xzvf dockerize.tar.gz \ &amp;&amp; rm dockerize.tar.gzRUN mkdir /appCOPY blog-eureka-1.0.0-SNAPSHOT.jar /app/app.jarENTRYPOINT [&quot;dockerize&quot;, &quot;-timeout&quot;, &quot;2m&quot;, &quot;-wait&quot;, &quot;http://39.108.61.221:8889/blog-eureka/prod/master&quot;, &quot;java&quot;, &quot;-Djava.security.egd=file:/dev/./urandom&quot;, &quot;-jar&quot;, &quot;/app/app.jar&quot;, &quot;--spring.profiles.active=prod&quot;]EXPOSE 8761 进入容器 1docker exec -it 容器id /bin/bash]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>GitLab</tag>
        <tag>持续集成</tag>
        <tag>持续部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud]]></title>
    <url>%2F2018%2F11%2F12%2FSpringCloud%2F</url>
    <content type="text"><![CDATA[Spring Cloud 简介Spring Cloud 是一个相对比较新的微服务框架，2016 才推出 1.0 的 Release 版本. 但是其更新特别快，几乎每 1-2 个月就有一次更新，虽然 Spring Cloud 时间最短, 但是相比 Dubbo 等 RPC 框架, Spring Cloud 提供的全套的分布式系统解决方案。 Spring Cloud 为开发者提供了在分布式系统（配置管理，服务发现，熔断，路由，微代理，控制总线，一次性 Token，全居琐，Leader 选举，分布式 Session，集群状态）中快速构建的工具，使用 Spring Cloud 的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。 Spring Cloud 创建统一的依赖管理简介Spring Cloud 项目都是基于 Spring Boot 进行开发，并且都是使用 Maven 做项目管理工具。在实际开发中，我们一般都会创建一个依赖管理项目作为 Maven 的 Parent 项目使用，这样做可以极大的方便我们对 Jar 包版本的统一管理。 创建依赖管理项目创建一个工程名为 mirror-springcloud-dependencies 的项目，pom.xml 配置文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;cn.mirrorming&lt;/groupId&gt; &lt;artifactId&gt;mirror-springcloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;mirror-springcloud-dependencies&lt;/name&gt; &lt;url&gt;http://www.mirrorming.cn&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;properties&gt; &lt;!-- Environment Settings --&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- Spring Settings --&gt; &lt;spring-cloud.version&gt;Finchley.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- Compiler 插件, 设定 JDK 版本 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 打包 jar 文件时，配置 manifest 文件，加入 lib 包的 jar 依赖 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;addMavenDescriptor&gt;false&lt;/addMavenDescriptor&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;!-- Add directory entries --&gt; &lt;addDefaultImplementationEntries&gt;true&lt;/addDefaultImplementationEntries&gt; &lt;addDefaultSpecificationEntries&gt;true&lt;/addDefaultSpecificationEntries&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- resource --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- install --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- clean --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- ant --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- dependency --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- Java Document Generate --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- YUI Compressor (CSS/JS压缩) --&gt; &lt;plugin&gt; &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt; &lt;artifactId&gt;yuicompressor-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.5.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compress&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;jswarn&gt;false&lt;/jswarn&gt; &lt;nosuffix&gt;true&lt;/nosuffix&gt; &lt;linebreakpos&gt;30000&lt;/linebreakpos&gt; &lt;force&gt;true&lt;/force&gt; &lt;includes&gt; &lt;include&gt;**/*.js&lt;/include&gt; &lt;include&gt;**/*.css&lt;/include&gt; &lt;/includes&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.min.js&lt;/exclude&gt; &lt;exclude&gt;**/*.min.css&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!-- 资源文件配置 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/*.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyun-repos&lt;/id&gt; &lt;name&gt;Aliyun Repository&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;sonatype-repos&lt;/id&gt; &lt;name&gt;Sonatype Repository&lt;/name&gt; &lt;url&gt;https://oss.sonatype.org/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;sonatype-repos-s&lt;/id&gt; &lt;name&gt;Sonatype Repository&lt;/name&gt; &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;aliyun-repos&lt;/id&gt; &lt;name&gt;Aliyun Repository&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; parent：继承了 Spring Boot 的 Parent，表示我们是一个 Spring Boot 工程 package：pom，表示该项目仅当做依赖项目，没有具体的实现代码 spring-cloud-dependencies：在 properties 配置中预定义了版本号为 Finchley.RC1 ，表示我们的 Spring Cloud 使用的是 F 版 build：配置了项目所需的各种插件 repositories：配置项目下载依赖时的第三方库 在实际开发中，我们所有的项目都会依赖这个 dependencies 项目，整个项目周期中的所有第三方依赖的版本也都由该项目进行管理。 Spring Cloud 服务注册与发现服务注册与发现在这里，我们需要用的组件是 Spring Cloud Netflix 的 Eureka，Eureka 是一个服务注册和发现模块 创建服务注册中心创建一个工程名为 mirror-springcloud-eureka 的项目，pom.xml 配置文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;cn.mirrorming&lt;/groupId&gt; &lt;artifactId&gt;mirror-springcloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../mirror-springcloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;mirror-springcloud-eureka&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;mirror-springcloud-eureka&lt;/name&gt; &lt;url&gt;http://www.mirrorming.cn&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;cn.mirrorming.demo.springcloud.eureka.EurekaApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; Application启动一个服务注册中心，只需要一个注解 @EnableEurekaServer 12345678910111213package cn.mirrorming.demo.springcloud.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; application.ymlEureka 是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下 Erureka Server 也是一个 Eureka Client ,必须要指定一个 Server。 123456789101112131415spring: application: name: mirror-springcloud-eurekaserver: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 通过 eureka.client.registerWithEureka:false 和 fetchRegistry:false 来表明自己是一个 Eureka Server. 操作界面Eureka Server 是有界面的，启动工程，打开浏览器访问： http://localhost:8761 Spring Cloud 创建服务提供者当 Client 向 Server 注册时，它会提供一些元数据，例如主机和端口，URL，主页等。Eureka Server 从每个 Client 实例接收心跳消息。 如果心跳超时，则通常将该实例从注册 Server 中删除。 创建一个工程名为 mirror-springcloud-service-admin 的项目，pom.xml 配置文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;cn.mirrorming&lt;/groupId&gt; &lt;artifactId&gt;mirror-springcloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../mirror-springcloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;mirror-springcloud-service-admin&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;mirror-springcloud-service-admin&lt;/name&gt; &lt;url&gt;http://www.mirrorming.cn&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;cn.mirrorming.demo.springcloud.service.admin.ServiceAdminApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; Application通过注解 @EnableEurekaClient 表明自己是一个 Eureka Client. 12345678910111213package cn.mirrorming.demo.springcloud.service.admin;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableEurekaClientpublic class ServiceAdminApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceAdminApplication.class, args); &#125;&#125; application.yml1234567891011spring: application: name: mirror-springcloud-service-adminserver: port: 8763eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 注意： 需要指明 spring.application.name，这个很重要，这在以后的服务与服务之间相互调用一般都是根据这个 name Controller12345678910111213141516171819package cn.mirrorming.demo.springcloud.service.admin.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class AdminController &#123; //访问http://localhost:8762/hi?message=HelloSpring @Value(&quot;$&#123;server.port&#125;&quot;) private String port; @RequestMapping(value = &quot;hi&quot;, method = RequestMethod.GET) public String sayHi(@RequestParam(value = &quot;message&quot;) String message) &#123; return String.format(&quot;Hi，your message is : %s i am from port : %s&quot;, message, port); &#125;&#125; 启动工程，打开 http://localhost:8761 ，即 Eureka Server 的网址： 你会发现一个服务已经注册在服务中了，服务名为 HELLO-SPRING-CLOUD-SERVICE-ADMIN ,端口为 8762 这时打开 http://localhost:8762/hi?message=HelloSpring ，你会在浏览器上看到 : 1Hi，your message is :&quot;HelloSpring&quot; i am from port：8762 Spring Cloud 创建服务消费者（Ribbon）在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于 http restful 的。Spring cloud 有两种服务调用方式，一种是 ribbon + restTemplate，另一种是 feign。在这一篇文章首先讲解下基于 ribbon + rest。 Ribbon 简介Ribbon 是一个负载均衡客户端，可以很好的控制 http 和 tcp 的一些行为。 准备工作 启动服务提供者（本教程案例工程为：hello-spring-cloud-service-admin），端口号为：8762 修改配置文件的端口号为：8763，启动后在 Eureka 中会注册两个实例，这相当于一个小集群 创建服务消费者创建一个工程名为 mirror-springcloud-web-admin-ribbon 的服务消费者项目，pom.xml 配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;cn.mirrorming&lt;/groupId&gt; &lt;artifactId&gt;mirror-springcloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../mirror-springcloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;mirror-springcloud-web-admin-ribbon&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;mirror-springcloud-web-admin-ribbon&lt;/name&gt; &lt;url&gt;http://www.mirrorming.cn&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;!-- 解决 thymeleaf 模板引擎一定要执行严格的 html5 格式校验问题 --&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;cn.mirrorming.demo.springcloud.web.admin.ribbon.WebAdminRibbonApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 主要是增加了 Ribbon 的依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; Application通过 @EnableDiscoveryClient 注解注册到服务中心 12345678910111213package cn.mirrorming.demo.springcloud.web.admin.ribbon;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class WebAdminRibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WebAdminRibbonApplication.class, args); &#125;&#125; application.yml设置程序端口号为：8764 1234567891011121314151617spring: application: name: mirror-springcloud-web-admin-ribbon thymeleaf: cache: false mode: LEGACYHTML5 encoding: UTF-8 servlet: content-type: text/htmlserver: port: 8764eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ Configuration配置注入 RestTemplate 的 Bean，并通过 @LoadBalanced 注解表明开启负载均衡功能 1234567891011121314package cn.mirrorming.demo.springcloud.web.admin.feign.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class RestTemplateConfiguration &#123; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 创建测试用的 Service在这里我们直接用的程序名替代了具体的 URL 地址，在 Ribbon 中它会根据服务名来选择具体的服务实例，根据服务实例在请求的时候会用具体的 URL 替换掉服务名，代码如下： 12345678910111213141516package cn.mirrorming.demo.springcloud.web.admin.feign.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;@Servicepublic class AdminService &#123; @Autowired private RestTemplate restTemplate; public String sayHi(String message) &#123; return restTemplate.getForObject(&quot;http://HELLO-SPRING-CLOUD-SERVICE-ADMIN/hi?message=&quot; + message, String.class); &#125;&#125; 创建测试用的 Controller1234567891011121314151617181920package cn.mirrorming.demo.springcloud.web.admin.feign.controller;import cn.mirrorming.demo.springcloud.web.admin.feign.service.AdminService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class AdminController &#123; @Autowired private AdminService adminService; @RequestMapping(value = &quot;hi&quot;, method = RequestMethod.GET) public String sayHi(@RequestParam String message) &#123; return adminService.sayHi(message); &#125;&#125; 测试访问在浏览器上多次访问 http://localhost:8764/hi?message=HelloRibbon 浏览器交替显示： 12Hi，your message is :&quot;HelloRibbon&quot; i am from port：8762Hi，your message is :&quot;HelloRibbon&quot; i am from port：8763 请求成功则表示我们已经成功实现了负载均衡功能来访问不同端口的实例 此时的架构 一个服务注册中心，Eureka Server，端口号为：8761 service-admin 工程运行了两个实例，端口号分别为：8762，8763 web-admin-ribbon 工程端口号为：8764 web-admin-ribbon 通过 RestTemplate 调用 service-admin 接口时因为启用了负载均衡功能故会轮流调用它的 8762 和 8763 端口 附在 IDEA 中配置一个工程启动多个实例步骤一点击 Run -&gt; Edit Configurations... 步骤二选择需要启动多实例的项目并去掉 Single instance only 前面的勾 步骤三通过修改 application.yml 配置文件的 server.port 的端口，启动多个实例，需要多个端口，分别进行启动即可。 Spring Cloud 创建服务消费者（Feign）Feign 简介Feign 是一个声明式的伪 Http 客户端，它使得写 Http 客户端变得更简单。使用 Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用 Feign 注解和 JAX-RS 注解。Feign 支持可插拔的编码器和解码器。Feign 默认集成了 Ribbon，并和 Eureka 结合，默认实现了负载均衡的效果 Feign 采用的是基于接口的注解 Feign 整合了 ribbon 创建服务消费者创建一个工程名为 mirror-springcloud-web-admin-feign 的服务消费者项目，pom.xml 配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;cn.mirrorming&lt;/groupId&gt; &lt;artifactId&gt;mirror-springcloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../mirror-springcloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;mirror-springcloud-web-admin-feign&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;mirror-springcloud-web-admin-feign&lt;/name&gt; &lt;url&gt;http://www.mirrorming.cn&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;!-- 解决 thymeleaf 模板引擎一定要执行严格的 html5 格式校验问题 --&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;cn.mirrorming.hello.spring.cloud.web.admin.feign.WebAdminFeignApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 主要是增加了 Feign 的依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; Application通过 @EnableFeignClients 注解开启 Feign 功能 123456789101112131415package cn.mirrorming.demo.springcloud.web.admin.feign;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class WebAdminFeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WebAdminFeignApplication.class, args); &#125;&#125; application.yml设置程序端口号为：8765 1234567891011121314151617spring: application: name: mirror-springcloud-web-admin-feign thymeleaf: cache: false mode: LEGACYHTML5 encoding: UTF-8 servlet: content-type: text/htmlserver: port: 8765eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 创建 Feign 接口通过 @FeignClient(&quot;服务名&quot;) 注解来指定调用哪个服务。代码如下： 123456789101112package cn.mirrorming.demo.springcloud.web.admin.feign.service;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;@FeignClient(value = &quot;hello-spring-cloud-service-admin&quot;)public interface AdminService &#123; @RequestMapping(value = &quot;hi&quot;, method = RequestMethod.GET) public String sayHi(@RequestParam(value = &quot;message&quot;) String message);&#125; 创建测试用的 Controller1234567891011121314151617181920package cn.mirrorming.demo.springcloud.web.admin.feign.controller;import cn.mirrorming.hello.spring.cloud.web.admin.feign.service.AdminService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class AdminController &#123; @Autowired private AdminService adminService; @RequestMapping(value = &quot;hi&quot;, method = RequestMethod.GET) public String sayHi(@RequestParam String message) &#123; return adminService.sayHi(message); &#125;&#125; 测试访问在浏览器上多次访问 http://localhost:8765/hi?message=HelloFeign 浏览器交替显示： 12Hi，your message is :&quot;HelloFeign&quot; i am from port：8762Hi，your message is :&quot;HelloFeign&quot; i am from port：8763 请求成功则表示我们已经成功实现了 Feign 功能来访问不同端口的实例 Spring Cloud 使用熔断器防止服务雪崩熔断器简介在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以通过 RPC 相互调用，在 Spring Cloud 中可以用 RestTemplate + Ribbon 和 Feign 来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证 100% 可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet 容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的 “雪崩” 效应。 为了解决这个问题，业界提出了熔断器模型。 Netflix 开源了 Hystrix 组件，实现了熔断器模式，Spring Cloud 对这一组件进行了整合。在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图： 较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystrix 是 5 秒 20 次） 熔断器将会被打开。 熔断器打开后，为了避免连锁故障，通过 fallback 方法可以直接返回一个固定值。 Ribbon 中使用熔断器在 pom.xml 中增加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 在 Application 中增加 @EnableHystrix 注解123456789101112131415package cn.mirrorming.demo.springcloud.web.admin.ribbon;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.hystrix.EnableHystrix;@SpringBootApplication@EnableDiscoveryClient@EnableHystrixpublic class WebAdminRibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WebAdminRibbonApplication.class, args); &#125;&#125; 在 Service 中增加 @HystrixCommand 注解在 Ribbon 调用方法上增加 @HystrixCommand 注解并指定 fallbackMethod 熔断方法 12345678910111213141516171819202122package cn.mirrorming.demo.springcloud.web.admin.ribbon.service;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;@Servicepublic class AdminService &#123; @Autowired private RestTemplate restTemplate; @HystrixCommand(fallbackMethod = &quot;hiError&quot;) public String sayHi(String message) &#123; return restTemplate.getForObject(&quot;http://HELLO-SPRING-CLOUD-SERVICE-ADMIN/hi?message=&quot; + message, String.class); &#125; public String hiError(String message) &#123; return &quot;Hi，your message is :\&quot;&quot; + message + &quot;\&quot; but request error.&quot;; &#125;&#125; 测试熔断器此时我们关闭服务提供者，再次请求 http://localhost:8764/hi?message=HelloRibbon 浏览器会显示： 1Hi，your message is :&quot;HelloRibbon&quot; but request error. Feign 中使用熔断器Feign 是自带熔断器的，但默认是关闭的。需要在配置文件中配置打开它，在配置文件增加以下代码： 123feign: hystrix: enabled: true 在 Service 中增加 fallback 指定类1234567891011121314package cn.mirrorming.demo.springcloud.web.admin.feign.service;import cn.mirrorming.demo.springcloud.web.admin.feign.service.hystrix.AdminServiceHystrix;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;@FeignClient(value = &quot;mirror-springcloud-service-admin&quot;, fallback = AdminServiceHystrix.class)public interface AdminService &#123; @RequestMapping(value = &quot;hi&quot;, method = RequestMethod.GET) public String sayHi(@RequestParam(value = &quot;message&quot;) String message);&#125; 创建熔断器类并实现对应的 Feign 接口123456789101112package cn.mirrorming.demo.springcloud.web.admin.feign.service.hystrix;import cn.mirrorming.demo.springcloud.web.admin.feign.service.AdminService;import org.springframework.stereotype.Component;@Componentpublic class AdminServiceHystrix implements AdminService &#123; @Override public String sayHi(String message) &#123; return &quot;hello，your message is :\&quot;&quot; + message + &quot;\&quot; but request error.&quot;; &#125;&#125; 测试熔断器此时我们关闭服务提供者，再次请求 http://localhost:8765/hi?message=HelloFeign 浏览器会显示： 1Hi，your message is :&quot;HelloFeign&quot; but request error. Spring Cloud 使用熔断器仪表盘监控使用熔断器仪表盘监控在 Ribbon 和 Feign 项目增加 Hystrix 仪表盘功能，两个项目的改造方式相同 在 pom.xml 中增加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; 在 Application 中增加 @EnableHystrixDashboard 注解1234567891011121314151617package cn.mirrorming.demo.springcloud.web.admin.ribbon;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.hystrix.EnableHystrix;import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;@SpringBootApplication@EnableDiscoveryClient@EnableHystrix@EnableHystrixDashboardpublic class WebAdminRibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WebAdminRibbonApplication.class, args); &#125;&#125; 创建 hystrix.stream 的 Servlet 配置Spring Boot 2.x 版本开启 Hystrix Dashboard 与 Spring Boot 1.x 的方式略有不同，需要增加一个 HystrixMetricsStreamServlet 的配置，代码如下： 1234567891011121314151617181920package cn.mirrorming.demo.springcloud.web.admin.ribbon.config;import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class HystrixDashboardConfiguration &#123; @Bean public ServletRegistrationBean getServlet() &#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;); registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;); return registrationBean; &#125;&#125; 测试 Hystrix Dashboard浏览器端访问 http://localhost:8764/hystrix 界面如下： 点击 Monitor Stream，进入下一个界面，访问 http://localhost:8764/hi?message=HelloRibbon 此时会出现监控界面： 附：Hystrix 说明什么情况下会触发 fallback 方法 名字 描述 触发fallback EMIT 值传递 NO SUCCESS 执行完成，没有错误 NO FAILURE 执行抛出异常 YES TIMEOUT 执行开始，但没有在允许的时间内完成 YES BAD_REQUEST 执行抛出HystrixBadRequestException NO SHORT_CIRCUITED 断路器打开，不尝试执行 YES THREAD_POOL_REJECTED 线程池拒绝，不尝试执行 YES SEMAPHORE_REJECTED 信号量拒绝，不尝试执行 YES fallback 方法在什么情况下会抛出异常 名字 描述 抛异常 FALLBACK_EMIT Fallback值传递 NO FALLBACK_SUCCESS Fallback执行完成，没有错误 NO FALLBACK_FAILURE Fallback执行抛出出错 YES FALLBACK_REJECTED Fallback信号量拒绝，不尝试执行 YES FALLBACK_MISSING 没有Fallback实例 YES Hystrix Dashboard 界面监控参数 Hystrix 常用配置信息超时时间（默认1000ms，单位：ms） hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds：在调用方配置，被该调用方的所有方法的超时时间都是该值，优先级低于下边的指定配置 hystrix.command.HystrixCommandKey.execution.isolation.thread.timeoutInMilliseconds：在调用方配置，被该调用方的指定方法（HystrixCommandKey 方法名）的超时时间是该值 线程池核心线程数 hystrix.threadpool.default.coreSize：默认为 10 Queue hystrix.threadpool.default.maxQueueSize：最大排队长度。默认 -1，使用 SynchronousQueue。其他值则使用 LinkedBlockingQueue。如果要从 -1 换成其他值则需重启，即该值不能动态调整，若要动态调整，需要使用到下边这个配置 hystrix.threadpool.default.queueSizeRejectionThreshold：排队线程数量阈值，默认为 5，达到时拒绝，如果配置了该选项，队列的大小是该队列 注意： 如果 maxQueueSize=-1 的话，则该选项不起作用 断路器 hystrix.command.default.circuitBreaker.requestVolumeThreshold：当在配置时间窗口内达到此数量的失败后，进行短路。默认 20 个（10s 内请求失败数量达到 20 个，断路器开） hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds：短路多久以后开始尝试是否恢复，默认 5s hystrix.command.default.circuitBreaker.errorThresholdPercentage：出错百分比阈值，当达到此阈值后，开始短路。默认 50% fallback hystrix.command.default.fallback.isolation.semaphore.maxConcurrentRequests：调用线程允许请求 HystrixCommand.GetFallback() 的最大数量，默认 10。超出时将会有异常抛出，注意：该项配置对于 THREAD 隔离模式也起作用 属性配置参数 参数说明：https://github.com/Netflix/Hystrix/wiki/Configuration HystrixProperty 参考代码：http://www.programcreek.com/java-api-examples/index.php?source_dir=Hystrix-master/hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/test/common/configuration/command/BasicCommandPropertiesTest.java Spring Cloud 使用路由网关统一访问接口使用路由网关统一访问接口在微服务架构中，需要几个基础的服务治理组件，包括服务注册与发现、服务消费、负载均衡、熔断器、智能路由、配置管理等，由这几个基础组件相互协作，共同组建了一个简单的微服务系统。一个简单的微服务系统如下图： 在 Spring Cloud 微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（Zuul、Ngnix），再到达服务网关（Zuul 集群），然后再到具体的服。服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理，配置服务的配置文件放在 GIT 仓库，方便开发人员随时改配置。 Zuul 简介Zuul 的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如 /api/user 转发到到 User 服务，/api/shop 转发到到 Shop 服务。Zuul 默认和 Ribbon 结合实现了负载均衡的功能。 创建路由网关创建一个工程名为 mirror-springcloud-zuul 的服务消费者项目，pom.xml 配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;cn.mirrorming&lt;/groupId&gt; &lt;artifactId&gt;mirror-springcloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../mirror-springcloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;mirror-springcloud-zuul&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;mirror-springcloud-zuul&lt;/name&gt; &lt;url&gt;http://www.mirrorming.cn&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;cn.mirrorming.hello.spring.cloud.zuul.ZuulApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 主要是增加了 Zuul 的依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt; Application增加 @EnableZuulProxy 注解开启 Zuul 功能 123456789101112131415package cn.mirrorming.demo.zuul;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.zuul.EnableZuulProxy;@SpringBootApplication@EnableEurekaClient@EnableZuulProxypublic class ZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulApplication.class, args); &#125;&#125; application.yml 设置端口号为：8769 增加 Zuul 配置 1234567891011121314151617181920spring: application: name: mirror-springcloud-zuulserver: port: 8769eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/zuul: routes: api-a: path: /api/a/** serviceId: mirror-springcloud-web-admin-ribbon api-b: path: /api/b/** serviceId: mirror-springcloud-web-admin-feign 路由说明： 以 /api/a 开头的请求都转发给 hello-spring-cloud-web-admin-ribbon 服务 以 /api/b 开头的请求都转发给 hello-spring-cloud-web-admin-feign 服务 测试访问依次运行 EurekaApplication、ServiceAdminApplication、WebAdminRibbonApplication、WebAdminFeignApplication、ZuulApplication 打开浏览器访问：http://localhost:8769/api/a/hi?message=HelloZuul 浏览器显示 1Hi，your message is :&quot;HelloZuul&quot; i am from port：8763 打开浏览器访问：http://localhost:8769/api/b/hi?message=HelloZuul 浏览器显示 1Hi，your message is :&quot;HelloZuul&quot; i am from port：8763 至此说明 Zuul 的路由功能配置成功 配置网关路由失败时的回调12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package cn.mirrorming.demo.zuul.fallback;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.cloud.netflix.zuul.filters.route.FallbackProvider;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.client.ClientHttpResponse;import org.springframework.stereotype.Component;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStream;import java.util.HashMap;import java.util.Map;@Componentpublic class WebAdminFeignFallbackProvide implements FallbackProvider &#123; @Override public String getRoute() &#123; // ServiceId，如果需要所有调用都支持回退，则 return "*" 或 return null return "hello-spring-cloud-web-admin-feign"; &#125; /** * 如果请求服务失败，则返回指定的信息给调用者 * * @param route * @param cause * @return */ @Override public ClientHttpResponse fallbackResponse(String route, Throwable cause) &#123; return new ClientHttpResponse() &#123; /** * 网关向 api 服务请求失败了，但是消费者客户端向网关发起的请求是成功的， * 不应该把 api 的 404,500 等问题抛给客户端 * 网关和 api 服务集群对于客户端来说是黑盒 * @return * @throws IOException */ @Override public HttpStatus getStatusCode() throws IOException &#123; return HttpStatus.OK; &#125; @Override public int getRawStatusCode() throws IOException &#123; return HttpStatus.OK.value(); &#125; @Override public String getStatusText() throws IOException &#123; return HttpStatus.OK.getReasonPhrase(); &#125; @Override public void close() &#123; &#125; @Override public InputStream getBody() throws IOException &#123; ObjectMapper objectMapper = new ObjectMapper(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("status", 200); map.put("message", "无法连接，请检查您的网络"); return new ByteArrayInputStream(objectMapper.writeValueAsString(map).getBytes("UTF-8")); &#125; @Override public HttpHeaders getHeaders() &#123; HttpHeaders headers = new HttpHeaders(); // 和 getBody 中的内容编码一致 headers.setContentType(MediaType.APPLICATION_JSON_UTF8); return headers; &#125; &#125;; &#125;&#125; Spring Cloud 使用路由网关的服务过滤功能使用路由网关的服务过滤功能Zuul 不仅仅只是路由，还有很多强大的功能，本节演示一下它的服务过滤功能，比如用在安全验证方面。 创建服务过滤器继承 ZuulFilter 类并在类上增加 @Component 注解就可以使用服务过滤功能了，非常简单方便 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package cn.mirrorming.hello.spring.cloud.zuul.filter;import com.netflix.zuul.ZuulFilter;import com.netflix.zuul.context.RequestContext;import com.netflix.zuul.exception.ZuulException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import javax.servlet.http.HttpServletRequest;import java.io.IOException;/** * Zuul 的服务过滤演示 * &lt;p&gt;Title: LoginFilter&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; */@Componentpublic class LoginFilter extends ZuulFilter &#123; private static final Logger logger = LoggerFactory.getLogger(LoginFilter.class); /** * 配置过滤类型，有四种不同生命周期的过滤器类型 * 1. pre：路由之前 * 2. routing：路由之时 * 3. post：路由之后 * 4. error：发送错误调用 * @return */ @Override public String filterType() &#123; return &quot;pre&quot;; &#125; /** * 配置过滤的顺序 * @return */ @Override public int filterOrder() &#123; return 0; &#125; /** * 配置是否需要过滤：true/需要，false/不需要 * @return */ @Override public boolean shouldFilter() &#123; return true; &#125; /** * 过滤器的具体业务代码 * @return * @throws ZuulException */ @Override public Object run() throws ZuulException &#123; RequestContext context = RequestContext.getCurrentContext(); HttpServletRequest request = context.getRequest(); logger.info(&quot;&#123;&#125; &gt;&gt;&gt; &#123;&#125;&quot;, request.getMethod(), request.getRequestURL().toString()); String token = request.getParameter(&quot;token&quot;); if (token == null) &#123; logger.warn(&quot;Token is empty&quot;); context.setSendZuulResponse(false); context.setResponseStatusCode(401); try &#123; context.getResponse().getWriter().write(&quot;Token is empty&quot;); &#125; catch (IOException e) &#123; &#125; &#125; else &#123; logger.info(&quot;OK&quot;); &#125; return null; &#125;&#125; filterType返回一个字符串代表过滤器的类型，在 Zuul 中定义了四种不同生命周期的过滤器类型 pre：路由之前 routing：路由之时 post： 路由之后 error：发送错误调用 filterOrder过滤的顺序 shouldFilter是否需要过滤，这里是 true，需要过滤 run过滤器的具体业务代码 测试过滤器浏览器访问：http://localhost:8769/api/a/hi?message=HelloZuul 网页显示 1Token is empty 浏览器访问：http://localhost:8769/api/b/hi?message=HelloZuul&amp;name=123 网页显示 1Hi，your message is :&quot;HelloZuul&quot; i am from port：8763 Spring Cloud 分布式配置中心在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在 Spring Cloud 中，有分布式配置中心组件 Spring Cloud Config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程 Git 仓库中。在 Spring Cloud Config 组件中，分两个角色，一是 Config Server，二是 Config Client。 分布式配置中心服务端创建一个工程名为 hello-spring-cloud-config 的项目，pom.xml 配置文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;cn.mirrorming&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../hello-spring-cloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-config&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;hello-spring-cloud-config&lt;/name&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;cn.mirrorming.hello.spring.cloud.config.ConfigApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 主要增加了 spring-cloud-config-server 依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt; Application通过 @EnableConfigServer 注解，开启配置服务器功能 123456789101112131415package cn.mirrorming.hello.spring.cloud.config;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.config.server.EnableConfigServer;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableConfigServer@EnableEurekaClientpublic class ConfigApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigApplication.class, args); &#125;&#125; application.yml增加 Config 相关配置，并设置端口号为：8888 1234567891011121314151617181920spring: application: name: hello-spring-cloud-config cloud: config: label: master server: git: uri: https://github.com/topsale/spring-cloud-config search-paths: respo username: password:server: port: 8888eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 相关配置说明，如下： spring.cloud.config.label：配置仓库的分支 spring.cloud.config.server.git.uri：配置 Git 仓库地址（GitHub、GitLab、码云 …） spring.cloud.config.server.git.search-paths：配置仓库路径（存放配置文件的目录） spring.cloud.config.server.git.username：访问 Git 仓库的账号 spring.cloud.config.server.git.password：访问 Git 仓库的密码 注意事项： 如果使用 GitLab 作为仓库的话，git.uri 需要在结尾加上 .git，GitHub 则不用 测试浏览器端访问：http://localhost:8888/config-client/dev/master 显示如下： 123456789101112131415161718&lt;Environment&gt; &lt;name&gt;config-client&lt;/name&gt; &lt;profiles&gt; &lt;profiles&gt;dev&lt;/profiles&gt; &lt;/profiles&gt; &lt;label&gt;master&lt;/label&gt; &lt;version&gt;9646007f931753d7e96a6dcc9ae34838897a91df&lt;/version&gt; &lt;state/&gt; &lt;propertySources&gt; &lt;propertySources&gt; &lt;name&gt;https://github.com/topsale/spring-cloud-config/respo/config-client-dev.yml&lt;/name&gt; &lt;source&gt; &lt;foo&gt;foo version 1&lt;/foo&gt; &lt;demo.message&gt;Hello Spring Config&lt;/demo.message&gt; &lt;/source&gt; &lt;/propertySources&gt; &lt;/propertySources&gt; &lt;/Environment&gt; 证明配置服务中心可以从远程程序获取配置信息 附：HTTP 请求地址和资源文件映射 http://ip:port/{application}/{profile}[/{label}] http://ip:port/{application}-{profile}.yml http://ip:port/{label}/{application}-{profile}.yml http://ip:port/{application}-{profile}.properties http://ip:port/{label}/{application}-{profile}.properties 分布式配置中心客户端创建一个工程名为 hello-spring-cloud-config-client 的项目，pom.xml 文件配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;cn.mirrorming&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../hello-spring-cloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-config-client&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;hello-spring-cloud-config-client&lt;/name&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;cn.mirrorming.hello.spring.cloud.config.client.ConfigClientApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 主要增加了 spring-cloud-starter-config 依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt; Application入口类没有需要特殊处理的地方，代码如下： 12345678910111213package cn.mirrorming.hello.spring.cloud.config.client;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class ConfigClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigClientApplication.class, args); &#125;&#125; application.yml增加 Config Client 相关配置，并设置端口号为：8889 1234567891011121314151617spring: application: name: hello-spring-cloud-config-client cloud: config: uri: http://localhost:8888 name: config-client label: master profile: devserver: port: 8889eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 相关配置说明，如下： spring.cloud.config.uri：配置服务中心的网址 spring.cloud.config.name：配置文件名称的前缀 spring.cloud.config.label：配置仓库的分支 1spring.cloud.config.profile ：配置文件的环境标识 dev：表示开发环境 test：表示测试环境 prod：表示生产环境 注意事项： 配置服务器的默认端口为 8888，如果修改了默认端口，则客户端项目就不能在 application.yml 或 application.properties 中配置 spring.cloud.config.uri，必须在 bootstrap.yml 或是 bootstrap.properties 中配置，原因是 bootstrap 开头的配置文件会被优先加载和配置，切记。 创建测试用 Controller我们创建一个 Controller 来测试一下通过远程仓库的配置文件注入 foo 属性 123456789101112131415161718package cn.mirrorming.hello.spring.cloud.config.client.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class TestConfigController &#123; @Value(&quot;$&#123;foo&#125;&quot;) private String foo; @RequestMapping(value = &quot;/hi&quot;, method = RequestMethod.GET) public String hi() &#123; return foo; &#125;&#125; 一般情况下，能够正常启动服务就说明注入是成功的。 测试访问浏览器端访问：http://localhost:8889/hi 显示如下： 1foo version 1 附：开启 Spring Boot Profile我们在做项目开发的时候，生产环境和测试环境的一些配置可能会不一样，有时候一些功能也可能会不一样，所以我们可能会在上线的时候手工修改这些配置信息。但是 Spring 中为我们提供了 Profile 这个功能。我们只需要在启动的时候添加一个虚拟机参数，激活自己环境所要用的 Profile 就可以了。 操作起来很简单，只需要为不同的环境编写专门的配置文件，如：application-dev.yml、application-prod.yml，启动项目时只需要增加一个命令参数 --spring.profiles.active=环境配置 即可，启动命令如下： 1java -jar hello-spring-cloud-web-admin-feign-1.0.0-SNAPSHOT.jar --spring.profiles.active=prod Spring Cloud 服务链路追踪这篇文章主要讲解服务追踪组件 ZipKin。 ZipKin 简介ZipKin 是一个开放源代码的分布式跟踪系统，由 Twitter 公司开源，它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。它的理论模型来自于 Google Dapper 论文。 每个服务向 ZipKin 报告计时数据，ZipKin 会根据调用关系通过 ZipKin UI 生成依赖关系图，显示了多少跟踪请求通过每个服务，该系统让开发者可通过一个 Web 前端轻松的收集和分析数据，例如用户每次请求服务的处理时间等，可方便的监测系统中存在的瓶颈。 服务追踪说明微服务架构是通过业务来划分服务的，使用 REST 调用。对外暴露的一个接口，可能需要很多个服务协同才能完成这个接口功能，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败。随着业务的不断扩张，服务之间互相调用会越来越复杂。 随着服务的越来越多，对调用链的分析会越来越复杂。它们之间的调用关系也许如下： 术语解释 Span：基本工作单元，例如，在一个新建的 Span 中发送一个 RPC 等同于发送一个回应请求给 RPC，Span 通过一个 64 位 ID 唯一标识，Trace 以另一个 64 位 ID 表示。 Trace：一系列 Spans 组成的一个树状结构，例如，如果你正在运行一个分布式大数据工程，你可能需要创建一个 Trace。 Annotation：用来即使记录一个事件的存在，一些核心 Annotations 用来定义一个请求的开始和结束 cs：Client Sent，客户端发起一个请求，这个 Annotation 描述了这个 Span 的开始 sr：Server Received，服务端获得请求并准备开始处理它，如果将其 sr 减去 cs 时间戳便可得到网络延迟 ss：Server Sent 表明请求处理的完成(当请求返回客户端)，如果 ss 减去 sr 时间戳便可得到服务端需要的处理请求时间 cr：Client Received 表明 Span 的结束，客户端成功接收到服务端的回复，如果 cr 减去 cs 时间戳便可得到客户端从服务端获取回复的所有所需时间 将 Span 和 Trace 在一个系统中使用 Zipkin 注解的过程图形化： 创建 ZipKin 服务端创建一个工程名为 hello-spring-cloud-zipkin 的项目，pom.xml 文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;cn.mirrorming&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../hello-spring-cloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;hello-spring-cloud-zipkin&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;hello-spring-cloud-zipkin&lt;/name&gt; &lt;url&gt;http://www.funtl.com&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;cn.mirrorming.hello.spring.cloud.zipkin.ZipKinApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 主要增加了 3 个依赖，io.zipkin.java:zipkin、io.zipkin.java:zipkin-server、io.zipkin.java:zipkin-autoconfigure-ui 123456789101112&lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt;&lt;/dependency&gt; 注意版本号为：2.10.1，这里没写版本号是因为我已将版本号托管到 dependencies 项目中 Application通过 @EnableZipkinServer 注解开启 Zipkin Server 功能 123456789101112131415package cn.mirrorming.hello.spring.cloud.zipkin;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import zipkin.server.internal.EnableZipkinServer;@SpringBootApplication@EnableEurekaClient@EnableZipkinServerpublic class ZipKinApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZipKinApplication.class, args); &#125;&#125; application.yml设置端口号为：9411，该端口号为 Zipkin Server 的默认端口号 1234567891011121314151617spring: application: name: hello-spring-cloud-zipkinserver: port: 9411eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/management: metrics: web: server: auto-time-requests: false 追踪服务在 所有需要被追踪的项目（就当前教程而言，除了 dependencies 项目外都需要被追踪，包括 Eureka Server） 中增加 spring-cloud-starter-zipkin 依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt; 在这些项目的 application.yml 配置文件中增加 Zipkin Server 的地址即可 123spring: zipkin: base-url: http://localhost:9411 测试追踪启动全部项目，打开浏览器访问：http://localhost:9411/ 会出现以下界面： 刷新之前项目中的全部测试接口（刷多几次） 点击 Find a trace，可以看到具体服务相互调用的数据 点击 Dependencies，可以发现服务的依赖关系 至此就代表 ZipKin 配置成功 Spring Boot Admin 服务监控随着开发周期的推移，项目会不断变大，切分出的服务也会越来越多，这时一个个的微服务构成了错综复杂的系统。对于各个微服务系统的健康状态、会话数量、并发数、服务资源、延迟等度量信息的收集就成为了一个挑战。Spring Boot Admin 应运而生，它正式基于这些需求开发出的一套功能强大的监控管理系统。 Spring Boot Admin 有两个角色组成，一个是 Spring Boot Admin Server，一个是 Spring Boot Admin Client，本章节将带领大家实现 Spring Boot Admin 的搭建。 Spring Boot Admin 服务端创建 Spring Boot Admin Server创建一个工程名为 hello-spring-cloud-admin 的项目，pom.xml 文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;cn.mirrorming&lt;/groupId&gt; &lt;artifactId&gt;mirror-springcloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../mirror-springcloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;mirror-springcloud-admin&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;mirror-springcloud-admin&lt;/name&gt; &lt;url&gt;http://www.mirrorming.cn&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jolokia&lt;/groupId&gt; &lt;artifactId&gt;jolokia-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;cn.mirrorming.demo.admin.AdminApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 主要增加了 2 个依赖，org.jolokia:jolokia-core、de.codecentric:spring-boot-admin-starter-server 12345678&lt;dependency&gt; &lt;groupId&gt;org.jolokia&lt;/groupId&gt; &lt;artifactId&gt;jolokia-core&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;&lt;/dependency&gt; 其中 spring-boot-admin-starter-server 的版本号为：2.0.0，这里没写版本号是因为我已将版本号托管到 dependencies 项目中 Application通过 @EnableAdminServer 注解开启 Admin 功能 123456789101112131415package cn.mirrorming.demo.admin;import de.codecentric.boot.admin.server.config.EnableAdminServer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableEurekaClient@EnableAdminServerpublic class AdminApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(AdminApplication.class, args); &#125;&#125; application.yml设置端口号为：8084 12345678910111213141516171819202122spring: application: name: mirror-springcloud-admin zipkin: base-url: http://localhost:9411server: port: 8084management: endpoint: health: show-details: always endpoints: web: exposure: include: [&quot;health&quot;, &quot;info&quot;]eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 主要增加了 Spring Boot Admin Server 的相关配置 12345678management: endpoint: health: show-details: always endpoints: web: exposure: include: [&quot;health&quot;, &quot;info&quot;] 测试访问监控中心打开浏览器访问：http://localhost:8084 会出现以下界面 Spring Boot Admin 客户端创建 Spring Boot Admin Client创建一个工程名为 hello-spring-cloud-admin-client 的项目，pom.xml 文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;cn.mirrorming&lt;/groupId&gt; &lt;artifactId&gt;mirror-springcloud-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../mirror-springcloud-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;mirror-springcloud-admin-client&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;mirror-springcloud-admin-client&lt;/name&gt; &lt;url&gt;http://www.mirrorming.cn&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jolokia&lt;/groupId&gt; &lt;artifactId&gt;jolokia-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Boot End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;cn.mirrorming.demo.admin.client.AdminClientApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 主要增加了 2 个依赖，org.jolokia:jolokia-core、de.codecentric:spring-boot-admin-starter-client 12345678&lt;dependency&gt; &lt;groupId&gt;org.jolokia&lt;/groupId&gt; &lt;artifactId&gt;jolokia-core&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;&lt;/dependency&gt; 其中 spring-boot-admin-starter-client 的版本号为：2.0.0，这里没写版本号是因为我已将版本号托管到 dependencies 项目中 Application程序入口类没有特别需要修改的地方 12345678910111213package cn.mirrorming.demo.admin.client;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class AdminClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(AdminClientApplication.class, args); &#125;&#125; application.yml设置端口号为：8085，并设置 Spring Boot Admin 的服务端地址 1234567891011121314151617spring: application: name: mirror-springcloud-admin-client boot: admin: client: url: http://localhost:8084 zipkin: base-url: http://localhost:9411server: port: 8085eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 主要增加了 Spring Boot Admin Client 相关配置 12345spring: boot: admin: client: url: http://localhost:8084 测试服务监控依次启动两个应用，打开浏览器访问：http://localhost:8084 界面显示如下 从图中可以看到，我们的 Admin Client 已经上线了，至此说明监控中心搭建成功 WallBoard Journal]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署一台Linux]]></title>
    <url>%2F2018%2F11%2F12%2FLinuxDeploy%2F</url>
    <content type="text"><![CDATA[部署一台LinuxUbuntu安装环境新装的Ubuntu如果无法连接 安装ssh的server: sudo apt-get install openssh-server 安装ftp的srever: sudo apt-get install vsftpd sudo apt update #更新库缓存 sudo apt -finstall #修复依赖与覆盖问题，完成安装 jdk和maven 环境变量 –&gt; vim /etc/profile 123456789设置所有者: chown -R root:root /usr/local/java/export MAVEN_HOME=/usr/local/apache-maven-3.5.3export JAVA_HOME=/usr/local/jdk1.8.0_152export JRE_HOME=/usr/local/jdk1.8.0_152/jreexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/libexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$MAVEN_HOME/bin:$PATH:$HOME/bin配置完成后执行: source /etc/profile Ubuntu 安装 Docker准备工作编辑数据源1vi /etc/apt/sources.list 删除全部内容并修改为1234deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse 使用 APT 安装安装必要的一些系统工具12sudo apt-get updatesudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common 安装 GPG 证书1curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 写入软件源信息1sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; 使用脚本自动安装在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装： 123$ curl -fsSL get.docker.com -o get-docker.sh# 可能会出现 404 错误，请移步下面的特别说明$ sudo sh get-docker.sh --mirror Aliyun 启动 Docker CE12$ sudo systemctl enable docker$ sudo systemctl start docker 镜像加速鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 国内镜像加速。 Docker 镜像加速器国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如： Docker 官方提供的中国 registry mirror 阿里云加速器 DaoCloud 加速器 我们以 Docker 官方加速器为例进行介绍。 Ubuntu 16.04+、Debian 8+、CentOS 7对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（不存在请新建该文件） 12345&#123; &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot; ]&#125; 重新启动服务。 12$ sudo systemctl daemon-reload$ sudo systemctl restart docker 检查加速器是否生效配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 docker info，如果从结果中看到了如下内容，说明配置成功。 12Registry Mirrors: https://registry.docker-cn.com/ Docker Compose 安装与卸载123$ docker-compose --versiondocker-compose version 1.17.1, build 6d101fb Linux 系统请使用以下介绍的方法安装。 二进制包在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。 例如，在 Linux 64 位系统上直接下载对应的二进制包。 12$ sudo curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose$ sudo chmod +x /usr/local/bin/docker-compose 卸载如果是二进制包方式安装的，删除二进制文件即可。 1$ sudo rm /usr/local/bin/docker-compose 基于 Docker 安装 GitLab1docker pull twang2218/gitlab-ce-zh docker-compose.yml 配置如下： 123456789101112131415161718192021version: &apos;3&apos;services: web: image: &apos;twang2218/gitlab-ce-zh&apos; restart: always hostname: &apos;192.168.72.144&apos; environment: TZ: &apos;Asia/Shanghai&apos; GITLAB_OMNIBUS_CONFIG: | external_url &apos;http://192.168.72.144:8082&apos; gitlab_rails[&apos;gitlab_shell_ssh_port&apos;] = 2222 unicorn[&apos;port&apos;] = 8888 nginx[&apos;listen_port&apos;] = 8082 ports: - &apos;8082:8082&apos; - &apos;8443:443&apos; - &apos;2222:22&apos; volumes: - /usr/local/docker/gitlab/config:/etc/gitlab - /usr/local/docker/gitlab/data:/var/opt/gitlab - /usr/local/docker/gitlab/logs:/var/log/gitlab 使用 SSH 的方式拉取和推送项目生成 SSH KEY使用 ssh-keygen 工具生成，位置在 Git 安装目录下，我的是 C:\Program Files\Git\usr\bin 输入命令： 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 执行成功后的效果： 12345678Microsoft Windows [版本 10.0.14393](c) 2016 Microsoft Corporation。保留所有权利。C:\Program Files\Git\usr\bin&gt;ssh-keygen -t rsa -C &quot;xxx@qq.com&quot;Generating public/private rsa key pair....C:\Program Files\Git\usr\bin&gt; 复制 SSH-KEY 信息到 GitLab秘钥位置在：C:\Users\你的用户名\.ssh 目录下，找到 id_rsa.pub 并使用编辑器打开 登录 GitLab，点击“用户头像”–&gt;“设置”–&gt;“SSH 密钥” 基于 Docker 安装 Nexus1docker pull sonatype/nexus3 我们使用 Docker 来安装和运行 Nexus，docker-compose.yml 配置如下： 12345678910version: &apos;3.1&apos;services: nexus: restart: always image: sonatype/nexus3 container_name: nexus ports: - 8081:8081 volumes: - /usr/local/docker/nexus/data:/nexus-data 注： 启动时如果出现权限问题可以使用：chmod 777 /usr/local/docker/nexus/data 赋予数据卷目录可读可写的权限 登录控制台验证安装地址：http://ip:port/用户名：admin密码：admin123 安装 Docker Registry 私服简介官方的Docker Hub 是一个用于管理公共镜像的地方，我们可以在上面找到我们想要的镜像，也可以把我们自己的镜像推送上去。但是，有时候不希望将自己的镜像放到公网当中，那么你就需要 Docker Registry，它可以用来存储和管理自己的镜像。 安装在之前的 Docker 私有仓库 章节中已经提到过如何配置和使用容器运行私有仓库，这里我们使用 docker-compose 来安装，配置如下： 12345678910version: &apos;3.1&apos;services: registry: image: registry restart: always container_name: registry ports: - 5000:5000 volumes: - /usr/local/docker/registry/data:/var/lib/registry 测试启动成功后需要测试服务端是否能够正常提供服务，有两种方式： 浏览器端访问 http://ip:5000/v2/ 终端访问 1curl http://ip:5000/v2/ 配置 Docker Registry 客户端我使用的是 Ubuntu Server 16.04 LTS 版本，属于 systemd 系统，需要在 /etc/docker/daemon.json 中增加如下内容（如果文件不存在请新建该文件） 12345678&#123; &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot; ], &quot;insecure-registries&quot;: [ &quot;ip:5000&quot; ]&#125; 之后重新启动服务。 12$ sudo systemctl daemon-reload$ sudo systemctl restart docker 检查客户端配置是否生效使用 docker info 命令手动检查，如果从配置中看到如下内容，说明配置成功（192.168.75.133 为教学案例 IP） 123Insecure Registries: 192.168.75.133:5000 127.0.0.0/8 测试镜像上传我们以 Nginx 为例测试镜像上传功能 1234567891011## 拉取一个镜像docker pull nginx## 查看全部镜像docker images## 标记本地镜像并指向目标仓库（ip:port/image_name:tag，该格式为标记版本号）docker tag nginx 192.168.75.133:5000/nginx## 提交镜像到仓库docker push 192.168.75.133:5000/nginx 查看全部镜像1curl -XGET http://192.168.75.133:5000/v2/_catalog 查看指定镜像以 Nginx 为例，查看已提交的列表 1curl -XGET http://192.168.75.133:5000/v2/nginx/tags/list 测试拉取镜像 先删除镜像 12docker rmi nginxdocker rmi 192.168.75.133:5000/nginx 再拉取镜像 1docker pull 192.168.75.133:5000/nginx 部署 Docker Registry WebUI私服安装成功后就可以使用 docker 命令行工具对 registry 做各种操作了。然而不太方便的地方是不能直观的查看 registry 中的资源情况。如果可以使用 UI 工具管理镜像就更好了。这里介绍两个 Docker Registry WebUI 工具 docker-registry-frontend docker-registry-web 两个工具的功能和界面都差不多，我们以 docker-registry-fontend 为例讲解 docker-registry-frontend我们使用 docker-compose 来安装和运行，docker-compose.yml 配置如下： 123456789101112version: &apos;3.1&apos;services: frontend: image: konradkleine/docker-registry-frontend:v2 ports: - 8181:80 volumes: - ./certs/frontend.crt:/etc/apache2/server.crt:ro - ./certs/frontend.key:/etc/apache2/server.key:ro environment: - ENV_DOCKER_REGISTRY_HOST=192.168.72.144 - ENV_DOCKER_REGISTRY_PORT=5000 注意：请将配置文件中的主机和端口换成自己仓库的地址 运行成功后在浏览器访问：http://192.168.75.144:5000 Docker Compose 实战 MySQLMySQL51234567891011121314151617181920212223version: &apos;3.1&apos;services: mysql: restart: always image: mysql:5.7.22 container_name: mysql ports: - 3306:3306 environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: xxx command: --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 --max_allowed_packet=128M --sql-mode=&quot;STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO&quot; volumes: - mysql-data:/var/lib/mysqlvolumes: mysql-data: MySQL81234567891011121314151617181920212223version: &apos;3.1&apos;services: db: image: mysql restart: always environment: MYSQL_ROOT_PASSWORD: xxx command: --default-authentication-plugin=mysql_native_password --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci --explicit_defaults_for_timestamp=true --lower_case_table_names=1 ports: - 3306:3306 volumes: - ./data:/var/lib/mysql adminer: image: adminer restart: always ports: - 8085:8085]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
        <tag>GitLab</tag>
        <tag>Registry</tag>
        <tag>Nexus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装Fastdfs]]></title>
    <url>%2F2018%2F10%2F12%2FFastDFS%2F</url>
    <content type="text"><![CDATA[FastDFS 安装我们基于 Docker 来安装 FastDFS 环境准备 libfastcommon.tar.gz fastdfs-5.11.tar.gz nginx-1.13.6.tar.gz fastdfs-nginx-module_v1.16.tar.gz 创建工作目录在 Linux 服务器上创建 /usr/local/docker/fastdfs/environment 目录 说明： /usr/local/docker/fastdfs：用于存放 docker-compose.yml 配置文件及 FastDFS 的数据卷 /usr/local/docker/fastdfs/environment：用于存放 Dockerfile 镜像配置文件及 FastDFS 所需环境 docker-compose.yml123456789version: &apos;3.1&apos;services: fastdfs: build: environment restart: always container_name: fastdfs volumes: - ./storage:/fastdfs/storage network_mode: host Dockerfile123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960FROM ubuntu:xenialMAINTAINER mirrorming@qq.com# 更新数据源WORKDIR /etc/aptRUN echo &apos;deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse&apos; &gt; sources.listRUN echo &apos;deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse&apos; &gt;&gt; sources.listRUN echo &apos;deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse&apos; &gt;&gt; sources.listRUN echo &apos;deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse&apos; &gt;&gt; sources.listRUN apt-get update# 安装依赖RUN apt-get install make gcc libpcre3-dev zlib1g-dev --assume-yes# 复制工具包ADD fastdfs-5.11.tar.gz /usr/local/srcADD fastdfs-nginx-module_v1.16.tar.gz /usr/local/srcADD libfastcommon.tar.gz /usr/local/srcADD nginx-1.13.6.tar.gz /usr/local/src# 安装 libfastcommonWORKDIR /usr/local/src/libfastcommonRUN ./make.sh &amp;&amp; ./make.sh install# 安装 FastDFSWORKDIR /usr/local/src/fastdfs-5.11RUN ./make.sh &amp;&amp; ./make.sh install# 配置 FastDFS 跟踪器ADD tracker.conf /etc/fdfsRUN mkdir -p /fastdfs/tracker# 配置 FastDFS 存储ADD storage.conf /etc/fdfsRUN mkdir -p /fastdfs/storage# 配置 FastDFS 客户端ADD client.conf /etc/fdfs# 配置 fastdfs-nginx-moduleADD config /usr/local/src/fastdfs-nginx-module/src# FastDFS 与 Nginx 集成WORKDIR /usr/local/src/nginx-1.13.6RUN ./configure --add-module=/usr/local/src/fastdfs-nginx-module/srcRUN make &amp;&amp; make installADD mod_fastdfs.conf /etc/fdfsWORKDIR /usr/local/src/fastdfs-5.11/confRUN cp http.conf mime.types /etc/fdfs/# 配置 NginxADD nginx.conf /usr/local/nginx/confCOPY entrypoint.sh /usr/local/bin/ENTRYPOINT [&quot;/usr/local/bin/entrypoint.sh&quot;]WORKDIR /EXPOSE 8888CMD [&quot;/bin/bash&quot;] entrypoint.sh1234#!/bin/sh/etc/init.d/fdfs_trackerd start/etc/init.d/fdfs_storaged start/usr/local/nginx/sbin/nginx -g &apos;daemon off;&apos; 注：Shell 创建后是无法直接使用的，需要赋予执行的权限，使用 chmod +x entrypoint.sh 命令 各种配置文件说明tracker.confFastDFS 跟踪器配置，容器中路径为：/etc/fdfs，修改为： 1base_path=/fastdfs/tracker storage.confFastDFS 存储配置，容器中路径为：/etc/fdfs，修改为： 1234base_path=/fastdfs/storagestore_path0=/fastdfs/storagetracker_server=192.168.72.144:22122http.server_port=8888 client.confFastDFS 客户端配置，容器中路径为：/etc/fdfs，修改为： 12base_path=/fastdfs/trackertracker_server=192.168.72.144:22122 configfastdfs-nginx-module 配置文件，容器中路径为：/usr/local/src/fastdfs-nginx-module/src，修改为： 1234567# 修改前CORE_INCS=&quot;$CORE_INCS /usr/local/include/fastdfs /usr/local/include/fastcommon/&quot;CORE_LIBS=&quot;$CORE_LIBS -L/usr/local/lib -lfastcommon -lfdfsclient&quot;# 修改后CORE_INCS=&quot;$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon/&quot;CORE_LIBS=&quot;$CORE_LIBS -L/usr/lib -lfastcommon -lfdfsclient&quot; mod_fastdfs.conffastdfs-nginx-module 配置文件，容器中路径为：/usr/local/src/fastdfs-nginx-module/src，修改为： 1234connect_timeout=10tracker_server=192.168.72.144:22122url_have_group_name = truestore_path0=/fastdfs/storage nginx.confNginx 配置文件，容器中路径为：/usr/local/src/nginx-1.13.6/conf，修改为： 1234567891011121314151617181920212223242526272829user root;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 8888; server_name localhost; location ~/group([0-9])/M00 &#123; ngx_fastdfs_module; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 1docker-compose build 启动容器1docker-compose up -d 测试上传交互式进入容器1docker exec -it fastdfs /bin/bash 测试文件上传1/usr/bin/fdfs_upload_file /etc/fdfs/client.conf /usr/local/src/fastdfs-5.11/INSTALL 服务器反馈上传地址1group1/M00/00/00/wKhIkFv6cNyATJ9qAAAeSwu9TgM5320442 测试 Nginx 访问1http://192.168.72.144:8888/group1/M00/00/00/wKhIkFv6cNyATJ9qAAAeSwu9TgM5320442]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Fastdfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知必会]]></title>
    <url>%2F2018%2F10%2F12%2FMySQL%2F</url>
    <content type="text"><![CDATA[MySQL必知必会笔记1. 了解SQL1.1 数据库基础1.1.1 什么是数据库 数据库(database) 保存有组织的数据的容器(通常是一个文件或以组文件) 数据库软件DBMS (数据库管理系统) 1.1.2 表 表(table) 某种特定类型的结构化清单 1.1.3 列和数据类型 列(column) 表中的一个字段. 所有表都是由一个或多个列组成的 数据类型(datatype) 所容许的数据的类型. 每个表列都有相应的数据类型, 它限制(或容许)该列中存储的数据. 1.1.4 行 行(row) 表中的一个记录 1.1.5 主键 主键(primary key) 一列(或一组列) , 其值能够唯一区分表中每个行. 表中任何列都可以作为主键, 只要它满足一下条件: 任意两行都不具有相同的主键值; 每个行都必须具有一个主键值(主键列不允许null值) 1.2 什么是SQL SQL(发音: S-Q-L或sequel) 是结构化查询语言(Structured Query Language) 的缩写 . 专门用来与数据库通信的语言. SQL不是某个特定数据库供应商的专有语言 , 几乎所有重要的DBMS都支持SQL 简单易学 尽管看上去很简单, 但它实际上是一种强有力的语言 , 灵活使用其语言元素 , 可以进行非常复杂和高级的数据库操作 . 2. MySQL 开源 , 一般可以免费使用 , 甚至修改 性能强 可信赖 实用 3. 使用MySQL3.1 连接为了连接到 MySQL 需要一下信息 主机名 / IP 端口 用户名 口令 3.2 选择数据库12345输入: use 数据库名输出: Database changed 3.3 了解数据库和表1show databases 1show tables 1show columns from 表名 show status用于显示广泛的服务器状态信息 show create database和show create table 分别用来显示创建特定的数据库或表的MySQL语句. show grants 用来显示授权用户的安全权限 show errors和show warnings 用来显示服务器错误或警告信息 4. 检索数据4.1 SELECT语句4.2 检索单个列1SELECT 列名 FROM 表名 4.3 检索多个列1select 列名,列名,列名 from 表名 4.4 检索所有列1select * from 表名 4.5 检索不同的行1SELECT 列名 FROM 表名 使用DISTINCT关键字可以让MySQL只返回不同(唯一)的行 1SELECT DISTINCT 列名 FROM 表名 4.6 限制结果1SELECT 列名 FROM 表名 LIMIT 5 注: LIMIT 指示MySQL返回不多于5行的数据 , 如果要返回下一个5行 , 可以指定检索的开始行和列数 1SELECT 列名 FROM 表名 LIMIT 5,5 4.7 使用完全限定的表名1SELECT 表名.列名 FROM 数据库名.表名 5. 排序检索数据5.1 排序数据1bSELECT 列名 FROM 表名 ORDER BY 列名1,列名2 5.2 指定排序方向 DESC 降序 asc升序 , 升序是默认的 , 不指定即升序 1SELECT 列名 FROM 表名 ORDER BY 列名1 DESC , 列名2 ASC 6. 过滤数据6.1 使用WHERE子句1SELECT 列名 FROM 表名 WHERE 条件 6.2 WHERE子句操作符 操作符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 在指定的两个值之间 ###6.3 空值检查 1SELECT 列名 FROM 表名 WHERE xxx IS NULL 7. 数据过滤7.1 组合WHERE子句####7.1.1 AND操作符 1SELECT 列名1,列名2 FROM 表名 WHERE 条件1 AND 条件2 7.1.2 OR操作符1SELECT 列名1,列名2 FROM 表名 WHERE 条件1 OR 条件2 7.1.3 计算次序需求 : 满足条件3 并且满足条件1 或者 条件2 的所有产品 1错误实例: SELECT 列名1,列名2 FROM 表名 WHERE 条件1 OR 条件2 AND 条件3 (由于AND符 在计算次序中优先级更高 , 此时得到的结果是 所有满足条件1 或者 满足条件2和条件3组合的 列) 1正确实例: SELECT 列名1,列名2 FROM 表名 WHERE (条件1 OR 条件2) AND 条件3 7.2 IN操作符1SELECT 列名1,列名2 FROM 表名 WHERE 列名3 IN(合法值1,合法值2) ORDER BY 列名 分析: 此语句会检索列名3中符合值1和值2的所有产品 . IN操作符后跟由逗号分隔的合法值清单 , 整个清单必须括在圆括号中 7.3 NOT操作符 WHERE子句中的NOT操作符有且只要一个功能 , 那就是否定它之后所跟的任何条件 1SELECT 列名1,列名2 FROM 表名 WHERE 列名3 NOT IN(合法值1,合法值2) ORDER BY 列名 8. 用通配符进行过滤8.1 LIKE操作符 通配符(wildcard): 用来匹配值的一部分的特殊字符. 搜索模式(search pattern): 由字面值 , 通配符或两者组合构成的搜索条件 8.1.1 百分号(%)通配符12345SELECT 列名1,列名2 FROM 表名 WHERE 列名 LIKE &apos;mirror%&apos;SELECT 列名1,列名2 FROM 表名 WHERE 列名 LIKE &apos;%mirror%&apos;SELECT 列名1,列名2 FROM 表名 WHERE 列名 LIKE &apos;mi%or&apos; 8.1.1 下划线(_)通配符 另一个有用的通配符是下划线(_) . 下划线的用途和%一样, 但下划线只匹配单个字符而不是多个字符 1SELECT 列名1,列名2 FROM 表名 WHERE 列名 LIKE &apos;_irror&apos; 8.2 使用通配符技巧 不用过度使用通配符 在确实需要使用通配符时 , 除非绝对有必要 , 否则不要把它们用来搜索模式的开始处 仔细注意通配符的位置 9. 用正则表达式进行搜索9.1 正则表达式介绍 所有种类的程序设计语言 , 文本编辑器 , 操作系统等都支持正则表达式 正则表达式用正则表达式语言来建立 , 正则表达式语言是用来完成刚讨论的所有工作以及更多工作的一种特殊语言 9.2 使用MySQL正则表达式9.2.1 基本字符匹配 检索列名3包含文本1000的所有行 1SELECT 列名1,列名2 FROM 表名 WHERE 列名3 REGEXP &apos;1000&apos; 使用正则表达式.000来检索列名3包含文本1000或2000或…的所有行 1SELECT 列名1,列名2 FROM 表名 WHERE 列名3 REGEXP &apos;.000&apos; 9.2.2 进行OR匹配 语句中使用了正则表达式1000|2000. | 为正则表达式的OR操作符 , 表达匹配其中之一 , 因此1000和2000都匹配并返回 1SELECT 列名1,列名2 FROM 表名 WHERE 列名3 REGEXP &apos;1000|2000&apos; 9.2.3 匹配几个字符之一 这里 , 使用正则表达式[123]mirror , [123]定义一组字符 , 它的意思是匹配1或2或3 , 因此1 mirror和 2 mirror都匹配返回 1SELECT 列名1,列名2 FROM 表名 WHERE 列名3 REGEXP &apos;[123]mirror&apos; 9.2.4 匹配范围 匹配1到5 1SELECT 列名1 FROM 表名 WHERE ,列名2 REGEXP &apos;[1-5]mirror&apos; 9.2.5 匹配特殊字符 为了匹配特殊字符 , 必须用\\为前导 . \\-表示查找- , \\.表达查找. 1SELECT 列名1 FROM 表名 WHERE ,列名2 REGEXP &apos;\\.&apos; 元字符 说明 \\f 换页 \\n 换行 \\r 回车 \\t 制表 \\v 纵向制表 匹配\ 使用\\\ 匹配\或\\? 多数正则表达式实现单个反斜杠转义特殊字符 , 但是MySQL要求两个反斜杠(MySQL自己解释一个 , 正则表达式库解释另一个) 9.2.6 匹配字符类 类 说明 [:alnum:] 任意字母和数字 (同[a-zA-Z0-9]) [:alpha:] 任意字符 (同[a-zA-Z]) [:blank:] 空格和制表 (同[\\t]) [:cntrl:] ASCII控制字符 (ASCII 0 到31和127) [:digit:] 任意数字 (同[0-9]) [:graph:] 与[:print:]相同 , 但不包含空格 [:lower:] 任意小写字母 (同[a-z]) [:print:] 任意可打印字符 [:punct:] 既不在[:alnum:]又不在[:cntrl:]中的任意字符 [:space:] 包含空格在内的任意空白字符 [:upper:] 任意大写字母 [:xdigit:] 任意十六进制数字(同[a-fA-F0-9]) 9.2.7 匹配多个实例 元字符 说明 * 0个或者多个匹配 + 1个或多个匹配 ? 0个或一个匹配(等于{0,1}) {n} 指定数目的匹配 {n,} 不少于指定数目的匹配 {n,m} 匹配数目的范围(m不超过255) 正则表达式\\([0-9] mirrors?\\) \\(匹配( [0-9] 匹配任意数字 , mirrors?匹配mirror和mirrors(s后的?使s可选 , 因为?匹配它前面的任何字符的0次或1次出现 , \\(匹配( 1SELECT 列名1,列名2 FROM 表名 WHERE 列名3 REGEXP &apos;\\([0-9] mirrors?\\)&apos; [:digit:]匹配任意数字 , 因而它为数字的一个集合 . {4}确切地要求它前面的字符(任意数字)出现4次 , 所以[:digit:]{4}匹配连在一起的任意4位数字 1SELECT 列名1,列名2 FROM 表名 WHERE 列名3 REGEXP &apos;[:digit:]&#123;4&#125;&apos; ####9.2.8 定位符 匹配特定位置的文本 , 可以使用定位符 元字符 说明 ^ 文本的开始 $ 文本的结尾 [[:&lt;:]] 词的开始 [[:&gt;:]] 词的结尾 10. 创建计算字段10.1 计算字段 字段(field)基本上与列(column)的意思相同,经常互换使用,不过数据库一般称为列,而术语字段通常用在计算字段连接上. 10.2 拼接字段 拼接(concatenate) 讲值联结到一起构成单个值 . 在 MySQL的 SELECT语句中 , 可使用 Concat() 函数来拼接两个列 . 1select Concat(列名1,&apos;(&apos;,列名2,&apos;)&apos;) from 表名 ORDER BY 列名1 Concat() 拼接串 , 即把多个串连接起来形成一个较长的串 . Concat() 需要一个或多个指定的串 , 各个串直接用逗号分隔 . 存储在列1中的名字 包含一个空格和一个左圆括号的串 存储在列2中的数据 包含一个右圆括号的串 RTrim() 函数去掉值右边的所有空格 . 通过使用RTrim() , 各个列都进行整理 . 1select Concat(RTrim(列名1),&apos;(&apos;,RTrim(列名2),&apos;)&apos;) AS 别名 from 表名 ORDER BY 列名1 10.3 执行算术运算例子: orders表包含收到的所有订单 , orderitems表包含每个订单中的各项物品 , order_price列包含订单中每项物品的单价 1SELECT prod_id,quantity,item_price,quantity*item_price AS expanded_price from orderitems where order_num=20005 SELECT Now() 利用Now函数返回当前日期和时间 11. 使用数据处理函数11.1 函数 SQL支持利用函数来处理数据 11.2 使用函数 用于处理文本串(如: 如删除或填充值 , 转换大小写) 的文本函数 用于数值数据上执行算术操作(如 : 返回绝对值 , 进行代数运算) 的数值函数 用于处理日期时间并从这些值长提取特定成分 (如: 返回两个日期之差 , 检查日期的有效性等) 的日期和时间函数 返回DBMS正使用的特殊信息(如: 返回用户登录信息 , 检查版本细节)的系统函数 11.2.1文本处理函数1SELECT 列名1,Upper(列名1) AS 别名 FROM 表名 ORDER BY 列名 函数 说明 Left() 返回串左边的字符 Length() 返回串的长度 Locate() 找出串的一个子串 Lower() 将串转换位小写 LTrim() 去掉串左边的空格 Right() 返回串右边的字符 RTrim() 去掉串右边的空格 Soundex() 返回串的SOUNDEX值 SubString() 返回子串的字符 Upper() 将串转换为大写 SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法! SOUNDEX是考虑了类似的发音字符和音节, 使得能对串进行发音比较而不是字母比较 1SELECT 列名1,列名2 FROM 表名 WHERE Soundex(列名2) = Soundex(&apos;读音&apos;) 会查询出发音相似的匹配项 11.2.2 日期和时间处理函数 日期和时间采用相应的数据类型和特殊的格式存储 , 以便能快速和有效地排序和过滤 , 并且能节省物理存储空间 函数 说明 AddDate() 增加一个日期(天,周等) AddTime() 增加一个时间(时,分等) CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个时间的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 1SELECT 列名1 FROM 表名 WHERE Date(时间列名) = &apos;2005-09-01&apos; 1SELECT 列名1 FROM 表名 WHERE Date(时间列名) BETWEEN &apos;2005-09-01&apos; AND &apos;2006-09-01&apos; 1SELECT 列名1 FROM 表名 WHERE Year(时间列名) =&apos;2005&apos; AND Month(时间列名) =&apos;9&apos; 检索出时间列名为2005年9月份的所有行 11.2.3 数值处理函数 数值处理函数仅处理数值数据 一般主要用于代数 , 三角或几何运算 , 因此没有串或日期时间处理函数使用那么频繁 函数 说明 Abs() 返回一个数的绝对值 Cos() 返回一个角度的余弦 Exp() 返回一个数的指数值 Mod() 返回除操作的余数 Pi() 返回圆周率 Rand() 返回一个随机数 Sin() 返回一个角度的正弦 Sqrt() 返回一个数的平方根 Tan() 返回一个角度的正切 12. 汇总数据12.1 聚集函数 运行在行组上 , 计算和返回单个值的函数 确定表中的行数 获得表中行组的和 找出表列(或所有行或某些特定的行)的最值和平均值 函数 说明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列之和 12.1.1 AVG()函数1SELECT AVG(列名) AS 别名 FROM 表名 12.1.2 COUNT()函数1SELECT COUNT(列名) AS 别名 FROM 表名 12.1.3 MAX()函数1SELECT MAX(列名) AS 别名 FROM 表名 MySQL允许将它用来返回任意列中的最大值 , 在用于文本数据时 , 如果数据俺早相应的列排序 , 则MAX() 返回最后一行 MAX() 函数忽略列值为NULL的行 12.1.4 MIN()函数1SELECT MIN(列名) AS 别名 FROM 表名 MySQL允许将它用来返回任意列中的最大值 , 在用于文本数据时 , 如果数据俺早相应的列排序 , 则MIN() 返回最前面的行 MIN() 函数忽略列值为NULL的行 12.1.5 SUM()函数1SELECT SUM(列名) AS 别名 FROM 表名 WHERE 条件 1SELECT SUM(列名1*列名2) AS 别名 FROM 表名 WHERE 条件 利用标准的算术操作符 , 所有聚集函数都可用来执行多个列上的计算 SUM() 函数会忽略NULL值的行 12.2 聚集不同值 ALL不需要指定 , 因为它是默认行为 , 如果不指定DISTINCT , 则假定为ALL 使用AVG() 函数返回某列的平均值 , 使用DISTINCT函数 , 平均值只考虑不同的值来计算 1SELECT AVG(DISTINCT 列名) AS 别名 FROM 表名 WHERE 条件 DISTINCT不能用于COUNT(*) . DISTINCT必须使用列名 . 不能用于计算或表达式 DISTINCT用于MAX()和MIN()没有意义 12.3 组合聚集函数123456SELECT COUNT(*) AS 别名, MIN(列名) AS 别名, MAX(列名) AS 别名, AVG(列名) AS 别名FROM 表名 13. 分组数据13.1 数据分组 分组数据允许把数据分为多个逻辑组 , 以便能对每个组进行聚集计算 13.2 创建分组GROUP BY的一些规定 GROUP BY子句可以包含任意数目的列 , 这使得能对分组进行嵌套 , 为数据分组提供更细致的控制 如果在GROUP BY子句中嵌套了分组 , 数据将在最后规定的分组上进行汇总 GROUP BY子句中取出的每个列都必须是检索列或有效的表达式(不能是聚集函数) , 如果在SELECT中使用表达式 , 则必须在GROUP BY子句中指定相同的表达式 . 不能使用别名 . 除聚集计算语句外 , SELECT语句中的每个列都必须在GROUP BY子句中给出 如果分组列中具有NULL值 , NULL将作为一个分组返回 . 如果列中有多行NULL值 , 它们将分为一组 GROUP BY子句必须出现在WHERE子句后 , ORDER BY子句之前 1SELECT 列名1,COUNT(*) AS 别名 FROM 表名 GROUP BY 列名1; 13.3 过滤分组除了能用GROUP BY分组数据外 ,MySQL还允许过滤分组 , 规定包括哪些分组 , 排除哪些分组 MySQL为此目的提供了另外的子句 , 那就是HAVING子句 , HAVING非常类似WHERE 事实上 , 目前为止所学过的所有类型的WHERE子句都可以用HAVING来替代 , 唯一的差别是WHERE过滤行而HAVING过滤分组 1234SELECT 列名1,COUNT(*) AS 别名 FROM 表名GROUP BY 别名1HAVING COUNT(*)&gt;=2; 过滤了COUNT&gt;=2的那些分组 WHERE在分组前进行过滤HAVING在分组后进行过滤 , WHERE排除的行不包括在分组中 , 这可能会改变计算值 , 从而影响HAVING子句中基于这些值过滤掉的分组 13.4 分组和排序 ORDER BY GROUP BY 排序产生的输出 分组行 , 但输出可能不是分组的顺序 任意列都可以使用(甚至非选择的列也可以使用) 只可能使用选择列或表达式列 , 而且必须使用每个选择列表达式 不一定需要 如果与聚集函数一起使用列(或表达式) , 则必须使用 12345SELECT 列名1,SUM(列名2*列名3) AS 别名 FROM 表名GROUP BY 别名1HAVING SUM(列名2*列名3)&gt;=50ORDER BY 别名 GROUP BY 子句用来按订单号(别名1 列)分组数据 , 以便SUM(*)函数能够返回总计订单价格 . HAVING子句过滤数据 , 使得只返回总计(订单价格)大于等于50的订单 , 最后用ORDER BY排序输出 13.5 SELECT子句顺序SELECT语句使用时必须遵守的次序 子句 说明 是否必须 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 LIMIT 要检索的行数 否 14. 使用子查询14.1 子查询 查询(query) 任何SQL语句都是查询 . 但此术语一般指SELECT语句 14.2 利用子查询进行过滤 可以把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句 例子: ​ 假如需要列出订购物品TNT2的所有客户 检索包含物品TNT2的所有订单的编号 检索具有前一步列出的订单编号的所有用户ID 检索前一步返回的所有客户ID的客户信息 第一条SELECT语句的含义很明确 , 对于prod_id为TNT2的所有订单物品 , 它检索其order_num列 . 123SELECT order_numFROM orderitemsWHERE prod_id = &quot;TNT2&quot; 下一步 , 查询具有订单20005和20007的客户ID . 123SELECT cust_idFROM ordersWHERE order_num IN (20005,20007) 把第一个查询变成子查询组合两个查询 123456SELECT cust_idFROM ordersWHERE order_num IN(SELECT order_numFROM orderitemsWHERE prod_id = &quot;TNT2&quot;) 在SELECT语句中 , 子查询总是从内向外处理 现在得到了订购物品TNT2的所有用户ID , 下一步检索这些客户ID的客户信息 123SELECT cust_name,cust_concactFROM customersWHERE cust_id IN(10001,10004) 把其中的WHERE子句转换为子查询而不是硬编码这些客户ID 1234567SELECT cust_name,cust_concactFROM customersWHERE cust_id IN(SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = &quot;TNT2&quot;)) 实际使用时由于性能的限制 , 不能嵌套太多的子查询 列必须匹配 : 在WHERE子句中使用子查询 , 应该保证SELECT语句具有返回与WHERE子句中相同数目的列 ​ 通常 , 子查询将返回单个列并且与单个列匹配 , 但如果需要也可以使用多个列 子查询可以一般与IN操作符结合使用 , 但也可以用于测试等于(=) , 不等于(&lt;&gt;)等 14.3 作为计算字段使用子查询例: ​ 假如需要显示customers表中的每个用户的订单总数 从customers表中检索客户列表 对于检索出的每个客户 , 统计其在orders表中的订单数目 对客户10001的订单进行计数 123SELECT COUNT(*) AS ordersFROM ordersWHERE cust_id = 10001 为了对每个客户执行COUNT(*)计算 , 应该将COUNT(*)作为一个子查询 1234567SELECT cust_name, cust_state, (SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id) AS ordersFROM customersORDER BY cust_name 相关子查询 : 涉及外部查询的子查询 15. 联结表15.1 联结 联结 : join 15.1.1 关系表 外键 (foreign key) 外键为某个表中的一列 , 它包含另一个表的主键值 , 定义了两个表之间的关系 总之 , 关系数据可以有效地存储和方便地处理 , 因此 , 关系数据库的可伸缩性远比非关系型数据库好 可伸缩性(scale) 能够适应不断增加的工作量 , 而不失败 , 设计良好的数据库或应用程序 称之为 可伸缩性好 15.1.2 为什么要用联结 维护引用完整性 重要的是 , 要理解联结不是物理实体 , 它在数据库中并不存在 , 联结由MySQL根据需要建立 , 它存在于查询的执行当中 15.2 创建联结1234SELECT 表名.列名1,表名.列名2,表名.列名3FROM 表名1,表名2WHERE 表名1.xxx_id = 表名2.xxx_idORDER BY 列名1,列名2 15.2.1 WHERE子句的重要性 笛卡儿积 (cartesian product) 由于没有联结条件的表关系返回的结果为笛卡儿积 . 检索出的行的数目将是第一个表中的行数乘以第二个表中的行数 15.2.2 内部联结1234SELECT 表名.列名1,表名.列名2,表名.列名3FROM 表名1INNER JOIN 表名2ON 表名1.xxx_id = 表名2.xxx_id 15.2.3 联结多个表12345SELECT 表名.列名1,表名.列名2,表名.列名3,表名.列名4FROM 表名1,表名2,表名3WHERE 表名1.xxx_id = 表名2.xxx_idAND 表名2.xxxx_id = 表名3.xxxx_idAND 条件 性能考虑 MySQL在运行时关联指定的每个表以处理联结 , 这种处理可能是非常耗费资源的 , 因此应该仔细 , 不要联结不必要的表 多做实验 正如所见 , 为执行任一给定的SQL操作 , 一般存在不止一种方法 , 很少有绝对正确或错误的方法 , 性能可能受到操作类型 , 表中数据量 , 是否存在索引的或键以及一些条件的影响 . 因此 , 有必要对不同的选择机制进行实验 , 以找出最适合具体情况的方法 16. 创建高级联结16.1 使用表别名例: 123SELECT Concat(RTrim(vend_name),&apos;(&apos;,RTrim(vend_country),&apos;)&apos;)AS vend_titleFROM vendorsORDER BY vend_name 12345SELECT 字段1,字段2FROM 表1 AS a , 表2 AS b , 表3 AS cWHERE a.xxxid = b.xxxidAND c.xxx_num = b.xxx_numAND 条件 16.2 使用不同类型的联结 简单联结: 内部联结 , 等值联结 其他联结: 自联结 , 自然联结 , 外部联结 16.2.1 自联结例: 1234SELECT p1.pro_id p1.prod_nameFROM products AS p1, products AS p2WHERE p1.vend_id = p2.vend_idAND p2.prod_id = &quot;xxx&quot; 此查询中需要的两张表实际上是相同的表 , 因此products表在FROM子句中出现两次 , 虽然这是完全合法的 , 但对products的引用具有二义性 , 因此MySQL不知道你引用的是products表中的哪个实例 自联结通常作为外部语句用来代替从相同表中检索数据时使用的子查询语句 , 虽然结果都是一样的 , 但是有时候处理联结远比处理子查询快得多 16.2.2 自然联结无论何时对表进行联结 , 应该至少有一个列出现在不止一个表中(被联结的列) . 内部联结返回所有数据 , 甚至相同的列多次出现 , 自然联结 排除多次出现 , 使每个列只返回一次 16.2.3外部联结 没有 *=操作符 MySQL不支持简化字符*=和=*的使用 , 这两种 操作符在其他DBMS中是很流行的 16.3 使用带聚集函数的联结例如: 如果要检索所有客户及每个客户所下的订单数 123456SELECT customers.cust_name, customers.cust_id, COUNT(orders.order_num) AS num_ordFROM customers INNER JOIN ordersON customers.cust_id = orders.cust_idGROUP BY customers.cust_id 16.4 使用 联结和联结条件 注意使用的联结类型 , 一般我们使用 内部联结 , 但使用外部联结也是有效的 保证使用正确的联结条件 , 否则将返回不正确的数据 应该总是提供联结条件 , 否则会得出笛卡儿积 在一个联结中可以 包含多个表 , 甚至对于每个联结可以采用不同的联结类型]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis Sentinel集群部署]]></title>
    <url>%2F2018%2F10%2F12%2FRedis%2F</url>
    <content type="text"><![CDATA[Redis 简介什么是 RedisRedis 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止 Redis 支持的键值数据类型如下： 字符串类型 散列类型 列表类型 集合类型 有序集合类型 Redis 的应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等） 分布式集群架构中的 session 分离 聊天室的在线好友列表 任务队列（秒杀、抢购、12306 等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒） Redis HA 方案HA(High Available，高可用性群集)机集群系统简称，是保证业务连续性的有效解决方案，一般有两个或两个以上的节点，且分为活动节点及备用节点。通常把正在执 行业务的称为活动节点，而作为活动节点的一个备份的则称为备用节点。当活动节点出现问题，导致正在运行的业务（任务）不能正常运行时，备用节点此时就会侦测到，并立即接续活动节点来执行业务。从而实现业务的不中断或短暂中断。 Redis 一般以主/从方式部署（这里讨论的应用从实例主要用于备份，主实例提供读写）该方式要实现 HA 主要有如下几种方案： keepalived： 通过 keepalived 的虚拟 IP，提供主从的统一访问，在主出现问题时， 通过 keepalived 运行脚本将从提升为主，待主恢复后先同步后自动变为主，该方案的好处是主从切换后，应用程序不需要知道(因为访问的虚拟 IP 不变)，坏处是引入 keepalived 增加部署复杂性，在有些情况下会导致数据丢失 zookeeper： 通过 zookeeper 来监控主从实例， 维护最新有效的 IP， 应用通过 zookeeper 取得 IP，对 Redis 进行访问，该方案需要编写大量的监控代码 sentinel： 通过 Sentinel 监控主从实例，自动进行故障恢复，该方案有个缺陷：因为主从实例地址( IP &amp; PORT )是不同的，当故障发生进行主从切换后，应用程序无法知道新地址，故在 Jedis2.2.2 中新增了对 Sentinel 的支持，应用通过 redis.clients.jedis.JedisSentinelPool.getResource() 取得的 Jedis 实例会及时更新到新的主实例地址 注意： sentinel 是解决 HA 问题的，cluster 是解决主从复制问题的，不重复，并且经常一起用 Redis Sentinel 集群部署Redis 集群可以在一组 redis 节点之间实现高可用性和 sharding。在集群中会有 1 个 master 和多个 slave 节点。当 master 节点失效时，应选举出一个 slave 节点作为新的 master。然而 Redis 本身(包括它的很多客户端)没有实现自动故障发现并进行主备切换的能力，需要外部的监控方案来实现自动故障恢复。 Redis Sentinel 是官方推荐的高可用性解决方案。它是 Redis 集群的监控管理工具，可以提供节点监控、通知、自动故障恢复和客户端配置发现服务。 Redis Sentinel 核心配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204# Example sentinel.conf# *** IMPORTANT ***## By default Sentinel will not be reachable from interfaces different than# localhost, either use the &apos;bind&apos; directive to bind to a list of network# interfaces, or disable protected mode with &quot;protected-mode no&quot; by# adding it to this configuration file.## Before doing that MAKE SURE the instance is protected from the outside# world via firewalling or other means.## For example you may use one of the following:## bind 127.0.0.1 192.168.1.1## protected-mode no# port &lt;sentinel-port&gt;# The port that this sentinel instance will run onport 26379# sentinel announce-ip &lt;ip&gt;# sentinel announce-port &lt;port&gt;## The above two configuration directives are useful in environments where,# because of NAT, Sentinel is reachable from outside via a non-local address.## When announce-ip is provided, the Sentinel will claim the specified IP address# in HELLO messages used to gossip its presence, instead of auto-detecting the# local address as it usually does.## Similarly when announce-port is provided and is valid and non-zero, Sentinel# will announce the specified TCP port.## The two options don&apos;t need to be used together, if only announce-ip is# provided, the Sentinel will announce the specified IP and the server port# as specified by the &quot;port&quot; option. If only announce-port is provided, the# Sentinel will announce the auto-detected local IP and the specified port.## Example:## sentinel announce-ip 1.2.3.4# dir &lt;working-directory&gt;# Every long running process should have a well-defined working directory.# For Redis Sentinel to chdir to /tmp at startup is the simplest thing# for the process to don&apos;t interfere with administrative tasks such as# unmounting filesystems.dir /tmp# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;## Tells Sentinel to monitor this master, and to consider it in O_DOWN# (Objectively Down) state only if at least &lt;quorum&gt; sentinels agree.## Note that whatever is the ODOWN quorum, a Sentinel will require to# be elected by the majority of the known Sentinels in order to# start a failover, so no failover can be performed in minority.## Slaves are auto-discovered, so you don&apos;t need to specify slaves in# any way. Sentinel itself will rewrite this configuration file adding# the slaves using additional configuration options.# Also note that the configuration file is rewritten when a# slave is promoted to master.## Note: master name should not include special characters or spaces.# The valid charset is A-z 0-9 and the three characters &quot;.-_&quot;.sentinel monitor mymaster 127.0.0.1 6379 2# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;## Set the password to use to authenticate with the master and slaves.# Useful if there is a password set in the Redis instances to monitor.## Note that the master password is also used for slaves, so it is not# possible to set a different password in masters and slaves instances# if you want to be able to monitor these instances with Sentinel.## However you can have Redis instances without the authentication enabled# mixed with Redis instances requiring the authentication (as long as the# password set is the same for all the instances requiring the password) as# the AUTH command will have no effect in Redis instances with authentication# switched off.## Example:## sentinel auth-pass mymaster MySUPER--secret-0123passw0rd# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;## Number of milliseconds the master (or any attached slave or sentinel) should# be unreachable (as in, not acceptable reply to PING, continuously, for the# specified period) in order to consider it in S_DOWN state (Subjectively# Down).## Default is 30 seconds.sentinel down-after-milliseconds mymaster 30000# sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;## How many slaves we can reconfigure to point to the new slave simultaneously# during the failover. Use a low number if you use the slaves to serve query# to avoid that all the slaves will be unreachable at about the same# time while performing the synchronization with the master.sentinel parallel-syncs mymaster 1# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;## Specifies the failover timeout in milliseconds. It is used in many ways:## - The time needed to re-start a failover after a previous failover was# already tried against the same master by a given Sentinel, is two# times the failover timeout.## - The time needed for a slave replicating to a wrong master according# to a Sentinel current configuration, to be forced to replicate# with the right master, is exactly the failover timeout (counting since# the moment a Sentinel detected the misconfiguration).## - The time needed to cancel a failover that is already in progress but# did not produced any configuration change (SLAVEOF NO ONE yet not# acknowledged by the promoted slave).## - The maximum time a failover in progress waits for all the slaves to be# reconfigured as slaves of the new master. However even after this time# the slaves will be reconfigured by the Sentinels anyway, but not with# the exact parallel-syncs progression as specified.## Default is 3 minutes.sentinel failover-timeout mymaster 180000# SCRIPTS EXECUTION## sentinel notification-script and sentinel reconfig-script are used in order# to configure scripts that are called to notify the system administrator# or to reconfigure clients after a failover. The scripts are executed# with the following rules for error handling:## If script exits with &quot;1&quot; the execution is retried later (up to a maximum# number of times currently set to 10).## If script exits with &quot;2&quot; (or an higher value) the script execution is# not retried.## If script terminates because it receives a signal the behavior is the same# as exit code 1.## A script has a maximum running time of 60 seconds. After this limit is# reached the script is terminated with a SIGKILL and the execution retried.# NOTIFICATION SCRIPT## sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;# # Call the specified notification script for any sentinel event that is# generated in the WARNING level (for instance -sdown, -odown, and so forth).# This script should notify the system administrator via email, SMS, or any# other messaging system, that there is something wrong with the monitored# Redis systems.## The script is called with just two arguments: the first is the event type# and the second the event description.## The script must exist and be executable in order for sentinel to start if# this option is provided.## Example:## sentinel notification-script mymaster /var/redis/notify.sh# CLIENTS RECONFIGURATION SCRIPT## sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;## When the master changed because of a failover a script can be called in# order to perform application-specific tasks to notify the clients that the# configuration has changed and the master is at a different address.# # The following arguments are passed to the script:## &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;## &lt;state&gt; is currently always &quot;failover&quot;# &lt;role&gt; is either &quot;leader&quot; or &quot;observer&quot;# # The arguments from-ip, from-port, to-ip, to-port are used to communicate# the old address of the master and the new address of the elected slave# (now a master).## This script should be resistant to multiple invocations.## Example:## sentinel client-reconfig-script mymaster /var/redis/reconfig.sh# SECURITY## By default SENTINEL SET will not be able to change the notification-script# and client-reconfig-script at runtime. This avoids a trivial security issue# where clients can set the script to anything and trigger a failover in order# to get the program executed.sentinel deny-scripts-reconfig yes 搭建 Redis 集群搭建一主两从环境，docker-compose.yml 配置如下： 123456789101112131415161718192021version: &apos;3.1&apos;services: master: image: redis container_name: redis-master ports: - 6379:6379 slave1: image: redis container_name: redis-slave-1 ports: - 6380:6379 command: redis-server --slaveof redis-master 6379 slave2: image: redis container_name: redis-slave-2 ports: - 6381:6379 command: redis-server --slaveof redis-master 6379 搭建 Sentinel 集群我们至少需要创建三个 Sentinel 服务，docker-compose.yml 配置如下： 12345678910111213141516171819202122232425262728version: &apos;3.1&apos;services: sentinel1: image: redis container_name: redis-sentinel-1 ports: - 26379:26379 command: redis-sentinel /usr/local/etc/redis/sentinel.conf volumes: - ./sentinel1.conf:/usr/local/etc/redis/sentinel.conf sentinel2: image: redis container_name: redis-sentinel-2 ports: - 26380:26379 command: redis-sentinel /usr/local/etc/redis/sentinel.conf volumes: - ./sentinel2.conf:/usr/local/etc/redis/sentinel.conf sentinel3: image: redis container_name: redis-sentinel-3 ports: - 26381:26379 command: redis-sentinel /usr/local/etc/redis/sentinel.conf volumes: - ./sentinel3.conf:/usr/local/etc/redis/sentinel.conf 修改 Sentinel 配置文件需要三份 sentinel.conf 配置文件，分别为 sentinel1.conf，sentinel2.conf，sentinel3.conf，配置文件内容相同 12345678port 26379dir /tmp# 自定义集群名，其中 127.0.0.1 为 redis-master 的 ip，6379 为 redis-master 的端口，2 为最小投票数（因为有 3 台 Sentinel 所以可以设置成 2）sentinel monitor mymaster 127.0.0.1 6379 2sentinel down-after-milliseconds mymaster 30000sentinel parallel-syncs mymaster 1sentinel failover-timeout mymaster 180000sentinel deny-scripts-reconfig yes 查看集群是否生效进入 Sentinel 容器，使用 Sentinel API 查看监控情况： 1234docker exec -it redis-sentinel-1 /bin/bashredis-cli -p 26379sentinel master mymastersentinel slaves mymaster Redis 命令汇总参考资料http://redisdoc.com/http://redis.io/commands Redis连接操作相关的命令 ping：测试连接是否存活如果正常会返回 pong echo：打印 select：切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值 quit：关闭连接（connection） auth：简单密码认证 服务端相关命令 time：返回当前服务器时间 client list: 返回所有连接到服务器的客户端信息和统计数据 参见 http://redisdoc.com/server/client_list.html client kill ip:port：关闭地址为 ip:port 的客户端 save：将数据同步保存到磁盘 bgsave：将数据异步保存到磁盘 lastsave：返回上次成功将数据保存到磁盘的Unix时戳 shundown：将数据同步保存到磁盘，然后关闭服务 info：提供服务器的信息和统计 config resetstat：重置 info 命令中的某些统计数据 config get：获取配置文件信息 config set：动态地调整 Redis 服务器的配置(configuration)而无须重启，可以修改的配置参数可以使用命令 CONFIG GET * 来列出 config rewrite：Redis 服务器时所指定的 redis.conf 文件进行改写 monitor：实时转储收到的请求 slaveof：改变复制策略设置 发布订阅相关命令 psubscribe：订阅一个或多个符合给定模式的频道 例如 psubscribe news. tweet. publish：将信息 message 发送到指定的频道 channel 例如 publish msg “good morning” pubsub channels：列出当前的活跃频道 例如 PUBSUB CHANNELS news.i* pubsub numsub：返回给定频道的订阅者数量 例如 PUBSUB NUMSUB news.it news.internet news.sport news.music pubsub numpat：返回客户端订阅的所有模式的数量总和 punsubscribe：指示客户端退订所有给定模式。 subscribe：订阅给定的一个或多个频道的信息。例如 subscribe msg chat_room unsubscribe：指示客户端退订给定的频道。 对 KEY 操作的命令 exists(key)：确认一个 key 是否存在 del(key)：删除一个 key type(key)：返回值的类型 keys(pattern)：返回满足给定 pattern 的所有 key randomkey：随机返回 key 空间的一个 keyrename(oldname, newname)：重命名 key dbsize：返回当前数据库中 key 的数目 expire：设定一个 key 的活动时间（s） ttl：获得一个 key 的活动时间 move(key, dbindex)：移动当前数据库中的 key 到 dbindex 数据库 flushdb：删除当前选择数据库中的所有 key flushall：删除所有数据库中的所有 key 对 String 操作的命令 set(key, value)：给数据库中名称为 key 的 string 赋予值 value get(key)：返回数据库中名称为 key 的 string 的 value getset(key, value)：给名称为 key 的 string 赋予上一次的 value mget(key1, key2,…, key N)：返回库中多个 string 的 value setnx(key, value)：添加 string，名称为 key，值为 value setex(key, time, value)：向库中添加 string，设定过期时间 time mset(key N, value N)：批量设置多个 string 的值 msetnx(key N, value N)：如果所有名称为 key i 的 string 都不存在 incr(key)：名称为 key 的 string 增 1 操作 incrby(key, integer)：名称为 key 的 string 增加 integer decr(key)：名称为 key 的 string 减 1 操作 decrby(key, integer)：名称为 key 的 string 减少 integer append(key, value)：名称为 key 的 string 的值附加 value substr(key, start, end)：返回名称为 key 的 string 的 value 的子串 对 List 操作的命令 rpush(key, value)：在名称为 key 的 list 尾添加一个值为 value 的元素 lpush(key, value)：在名称为 key 的 list 头添加一个值为 value 的元素 llen(key)：返回名称为 key 的 list 的长度 lrange(key, start, end)：返回名称为 key 的 list 中 start 至 end 之间的元素 ltrim(key, start, end)：截取名称为 key 的 list lindex(key, index)：返回名称为 key 的 list 中 index 位置的元素 lset(key, index, value)：给名称为 key 的 list 中 index 位置的元素赋值 lrem(key, count, value)：删除 count 个 key 的 list 中值为 value 的元素 lpop(key)：返回并删除名称为 key 的 list 中的首元素 rpop(key)：返回并删除名称为 key 的 list 中的尾元素 blpop(key1, key2,… key N, timeout)：lpop 命令的 block 版本。 brpop(key1, key2,… key N, timeout)：rpop 的 block 版本。 rpoplpush(srckey, dstkey)：返回并删除名称为 srckey 的 list 的尾元素，并将该元素添加到名称为 dstkey 的 list 的头部 对 Set 操作的命令 sadd(key, member)：向名称为 key 的 set 中添加元素 member srem(key, member) ：删除名称为 key 的 set 中的元素 member spop(key) ：随机返回并删除名称为 key 的 set 中一个元素 smove(srckey, dstkey, member) ：移到集合元素 scard(key) ：返回名称为 key 的 set 的基数 sismember(key, member) ：member 是否是名称为 key 的 set 的元素 sinter(key1, key2,…key N) ：求交集 sinterstore(dstkey, (keys)) ：求交集并将交集保存到 dstkey 的集合 sunion(key1, (keys)) ：求并集 sunionstore(dstkey, (keys)) ：求并集并将并集保存到 dstkey 的集合 sdiff(key1, (keys)) ：求差集 sdiffstore(dstkey, (keys)) ：求差集并将差集保存到 dstkey 的集合 smembers(key) ：返回名称为 key 的 set 的所有元素 srandmember(key) ：随机返回名称为 key 的 set 的一个元素 对 Hash 操作的命令 hset(key, field, value)：向名称为 key 的 hash 中添加元素 field hget(key, field)：返回名称为 key 的 hash 中 field 对应的 value hmget(key, (fields))：返回名称为 key 的 hash 中 field i 对应的 value hmset(key, (fields))：向名称为 key 的 hash 中添加元素 field hincrby(key, field, integer)：将名称为 key 的 hash 中 field 的 value 增加 integer hexists(key, field)：名称为 key 的 hash 中是否存在键为 field 的域 hdel(key, field)：删除名称为 key 的 hash 中键为 field 的域 hlen(key)：返回名称为 key 的 hash 中元素个数 hkeys(key)：返回名称为 key 的 hash 中所有键 hvals(key)：返回名称为 key 的 hash 中所有键对应的 value hgetall(key)：返回名称为 key 的 hash 中所有的键（field）及其对应的 value Redis Sentinel ping ：返回 pong 。 sentinel masters ：列出所有被监视的主服务器，以及这些主服务器的当前状态。 sentinel slaves ：列出给定主服务器的所有从服务器，以及这些从服务器的当前状态。 sentinel get-master-addr-by-name ：返回给定名字的主服务器的 IP 地址和端口号。如果这个主服务器正在执行故障转移操作，或者针对这个主服务器的故障转移操作已经完成，那么这个命令返回新的主服务器的 IP 地址和端口号。 sentinel reset ：重置所有名字和给定模式 pattern 相匹配的主服务器。pattern 参数是一个 Glob 风格的模式 重置操作清楚主服务器目前的所有状态，包括正在执行中的故障转移，并移除目前已经发现和关联的，主服务器的所有从服务器和 Sentinel 。 sentinel failover ：当主服务器失效时，在不询问其他 Sentinel 意见的情况下，强制开始一次自动故障迁移（不过发起故障转移的 Sentinel 会向其他 Sentinel 发送一个新的配置，其他 Sentinel 会根据这个配置进行相应的更新）。 (附)SpringCloud创建Redis缓存服务提供者创建项目创建一个名为 blog-service-redis 的服务提供者项目 POM123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;cn.mirrorming&lt;/groupId&gt; &lt;artifactId&gt;blog-dependencies&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../blog-dependencies/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;blog-service-redis&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;blog-service-redis&lt;/name&gt; &lt;url&gt;http://www.mirrorming.cn&lt;/url&gt; &lt;inceptionYear&gt;2018-Now&lt;/inceptionYear&gt; &lt;dependencies&gt; &lt;!-- Project Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.mirrorming&lt;/groupId&gt; &lt;artifactId&gt;blog-common&lt;/artifactId&gt; &lt;version&gt;$&#123;project.parent.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Project End --&gt; &lt;!-- Spring Cloud Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud End --&gt; &lt;!-- Spring Boot Admin Begin --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jolokia&lt;/groupId&gt; &lt;artifactId&gt;jolokia-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Admin End --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;cn.mirrorming.blog.service.redis.RedisApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 主要增加了 org.springframework.boot:spring-boot-starter-data-redis，org.apache.commons:commons-pool2 两个依赖 Application12345678910111213package cn.mirrormig.itoken.service.redis;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@EnableEurekaClient@SpringBootApplicationpublic class RedisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RedisApplication.class, args); &#125;&#125; 本地配置bootstrap.yml1234567spring: cloud: config: uri: http://localhost:8888 name: blog-service-redis label: master profile: dev bootstrap-prod.yml1234567spring: cloud: config: uri: http://192.168.75.137:8888 name: blog-service-redis label: master profile: prod 云配置blog-service-redis-dev.yml123456789101112131415161718192021222324252627282930313233343536spring: application: name: blog-service-redis boot: admin: client: url: http://localhost:8084 zipkin: base-url: http://localhost:9411 redis: lettuce: pool: max-active: 8 max-idle: 8 max-wait: -1ms min-idle: 0 sentinel: master: mymaster nodes: 192.168.75.140:26379server: port: 8502eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/management: endpoint: health: show-details: always endpoints: web: exposure: include: health,info blog-service-redis-prod.yml123456789101112131415161718192021222324252627282930313233343536spring: application: name: blog-service-redis boot: admin: client: url: http://192.168.75.137:8084 zipkin: base-url: http://192.168.75.137:9411 redis: lettuce: pool: max-active: 8 max-idle: 8 max-wait: -1ms min-idle: 0 sentinel: master: mymaster nodes: 192.168.75.140:26379, 192.168.75.140:26380, 192.168.75.140:26381server: port: 8502eureka: client: serviceUrl: defaultZone: http://192.168.75.137:8761/eureka/,http://192.168.75.137:8861/eureka/,http://192.168.75.137:8961/eureka/management: endpoint: health: show-details: always endpoints: web: exposure: include: health,info 创建接口RedisService123456package cn.mirrormig.itoken.service.redis.service;public interface RedisService &#123; public void set(String key, Object value, long seconds); public Object get(String key);&#125; RedisServiceImpl12345678910111213141516171819202122232425package cn.mirrormig.blog.service.redis.service.impl;import cn.mirrormig.blog.service.redis.service.RedisService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Service;import java.util.concurrent.TimeUnit;@Servicepublic class RedisServiceImpl implements RedisService &#123; @Autowired private RedisTemplate redisTemplate; @Override public void set(String key, Object value, long seconds) &#123; redisTemplate.opsForValue().set(key, value, seconds, TimeUnit.SECONDS); &#125; @Override public Object get(String key) &#123; return redisTemplate.opsForValue().get(key); &#125;&#125; Controller12345678910111213141516171819202122232425262728293031323334package cn.mirrorming.blog.service.redis.controller;import cn.mirrorming.blog.service.redis.service.RedisService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class RedisController &#123; private static final String RESULT_OK = &quot;ok&quot;; @Autowired private RedisService redisService; @RequestMapping(value = &quot;put&quot;, method = RequestMethod.GET) public String set(String key, String value, long seconds) &#123; redisService.set(key, value, seconds); return RESULT_OK; &#125; @RequestMapping(value = &quot;find&quot;, method = RequestMethod.GET) public String find(String key) &#123; String json = null; Object obj = redisService.get(key); if (obj != null) &#123; json = (String) redisService.get(key); &#125; return json; &#125;&#125;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Sentinel</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker使用]]></title>
    <url>%2F2018%2F08%2F12%2FDocker%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Docker使用获取镜像Docker Hub 上有大量的高质量的镜像可以用。 从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为： 1docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 具体的选项可以通过 docker pull --help 命令看到，这里我们说一下镜像名称的格式。 Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。 仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。 比如： 123456789$ docker pull ubuntu:16.0416.04: Pulling from library/ubuntubf5d46315322: Pull complete9f13e0ac480c: Pull completee8988b5b3097: Pull complete40af181810e7: Pull completee6f7c7e5c03e: Pull completeDigest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbeStatus: Downloaded newer image for ubuntu:16.04 上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 ubuntu:16.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 16.04 的镜像。 从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。 在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 sha256 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。 如果从 Docker Hub 下载镜像非常缓慢，可以参照 镜像加速器 一节配置加速器。 运行有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 ubuntu:16.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。 1234567891011121314$ docker run -it --rm \ ubuntu:16.04 \ bashroot@e7009c6ce357:/# cat /etc/os-releaseNAME=&quot;Ubuntu&quot;VERSION=&quot;16.04.4 LTS, Trusty Tahr&quot;ID=ubuntuID_LIKE=debianPRETTY_NAME=&quot;Ubuntu 16.04.4 LTS&quot;VERSION_ID=&quot;16.04&quot;HOME_URL=&quot;http://www.ubuntu.com/&quot;SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot; docker run 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。 -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 --rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。 ubuntu:16.04：这是指用 ubuntu:16.04 镜像为基础来启动容器。 bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。 进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 16.04.4 LTS 系统。 最后我们通过 exit 退出了这个容器。 列出镜像要想列出已经下载下来的镜像，可以使用 docker image ls 命令。 123456789$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEredis latest 5f515359c7f8 5 days ago 183 MBnginx latest 05a60462f8ba 5 days ago 181 MBmongo 3.2 fe9198c04d62 5 days ago 342 MB&lt;none&gt; &lt;none&gt; 00285df0df87 5 days ago 342 MBubuntu 16.04 f753707788c5 4 weeks ago 127 MBubuntu latest f753707788c5 4 weeks ago 127 MBubuntu 14.04 1e0c3dd64ccd 4 weeks ago 188 MB 列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。 其中仓库名、标签在之前的基础概念章节已经介绍过了。镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个标签。因此，在上面的例子中，我们可以看到 ubuntu:16.04 和 ubuntu:latest 拥有相同的 ID，因为它们对应的是同一个镜像。 镜像体积如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，ubuntu:16.04 镜像大小，在这里是 127 MB，但是在 Docker Hub 显示的却是 50 MB。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 docker image ls 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。 另外一个需要注意的问题是，docker image ls 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。 你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。 1234567$ docker system dfTYPE TOTAL ACTIVE SIZE RECLAIMABLEImages 24 0 1.992GB 1.992GB (100%)Containers 1 0 62.82MB 62.82MB (100%)Local Volumes 9 0 652.2MB 652.2MB (100%)Build Cache 0B 0B 虚悬镜像上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 &lt;none&gt;。： 1&lt;none&gt; &lt;none&gt; 00285df0df87 5 days ago 342 MB 这个镜像原本是有镜像名和标签的，原来为 mongo:3.2，随着官方镜像维护，发布了新版本后，重新 docker pull mongo:3.2 时，mongo:3.2 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 &lt;none&gt;。除了 docker pull 可能导致这种情况，docker build 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 &lt;none&gt; 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像： 123$ docker image ls -f dangling=trueREPOSITORY TAG IMAGE ID CREATED SIZE&lt;none&gt; &lt;none&gt; 00285df0df87 5 days ago 342 MB 一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。 1$ docker image prune 中间层镜像为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。 1$ docker image ls -a 这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。 列出部分镜像不加任何参数的情况下，docker image ls 会列出所有顶级镜像，但是有时候我们只希望列出部分镜像。docker image ls 有好几个参数可以帮助做到这个事情。 根据仓库名列出镜像 12345$ docker image ls ubuntuREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 16.04 f753707788c5 4 weeks ago 127 MBubuntu latest f753707788c5 4 weeks ago 127 MBubuntu 14.04 1e0c3dd64ccd 4 weeks ago 188 MB 列出特定的某个镜像，也就是说指定仓库名和标签 123$ docker image ls ubuntu:16.04REPOSITORY TAG IMAGE ID CREATED SIZEubuntu 16.04 f753707788c5 4 weeks ago 127 MB 除此以外，docker image ls 还支持强大的过滤器参数 --filter，或者简写 -f。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 mongo:3.2 之后建立的镜像，可以用下面的命令： 1234$ docker image ls -f since=mongo:3.2REPOSITORY TAG IMAGE ID CREATED SIZEredis latest 5f515359c7f8 5 days ago 183 MBnginx latest 05a60462f8ba 5 days ago 181 MB 想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。 此外，如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。 12$ docker image ls -f label=com.example.version=0.1... 以特定格式显示默认情况下，docker image ls 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 docker image ls 把所有的虚悬镜像的 ID 列出来，然后才可以交给 docker image rm 命令作为参数来删除指定的这些镜像，这个时候就用到了 -q 参数。 12345678$ docker image ls -q5f515359c7f805a60462f8bafe9198c04d6200285df0df87f753707788c5f753707788c51e0c3dd64ccd --filter 配合 -q 产生出指定范围的 ID 列表，然后送给另一个 docker 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。 另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 Go 的模板语法。 比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名： 12345678$ docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;5f515359c7f8: redis05a60462f8ba: nginxfe9198c04d62: mongo00285df0df87: &lt;none&gt;f753707788c5: ubuntuf753707788c5: ubuntu1e0c3dd64ccd: ubuntu 或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列： 123456789$ docker image ls --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot;IMAGE ID REPOSITORY TAG5f515359c7f8 redis latest05a60462f8ba nginx latestfe9198c04d62 mongo 3.200285df0df87 &lt;none&gt; &lt;none&gt;f753707788c5 ubuntu 16.04f753707788c5 ubuntu latest1e0c3dd64ccd ubuntu 14.04 删除本地的镜像如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为： 1$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] 用 ID、镜像名、摘要删除镜像其中，&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。 比如我们有这么一些镜像： 123456$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 0584b3d2cf6d 3 weeks ago 196.5 MBredis alpine 501ad78535f0 3 weeks ago 21.03 MBdocker latest cf693ec9b5c7 3 weeks ago 105.1 MBnginx latest e43d811ce2f4 5 weeks ago 181.5 MB 我们可以用镜像的完整 ID，也称为 长 ID，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 短 ID 来删除镜像。docker image ls 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。 比如这里，如果我们要删除 redis:alpine 镜像，可以执行： 123456789$ docker image rm 501Untagged: redis:alpineUntagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86dDeleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899bDeleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2faDeleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7 我们也可以用镜像名，也就是 &lt;仓库名&gt;:&lt;标签&gt;，来删除镜像。 12345$ docker image rm centosUntagged: centos:latestUntagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366cDeleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8aDeleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38 当然，更精确的是使用 镜像摘要 删除镜像。 123456$ docker image ls --digestsREPOSITORY TAG DIGEST IMAGE ID CREATED SIZEnode slim sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228 6e0c4c8e3913 3 weeks ago 214 MB$ docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228 Untagged 和 Deleted如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 Untagged，另一类是 Deleted。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。 因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 Untagged 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 Delete 行为就不会发生。所以并非所有的 docker image rm 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。 当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变动非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 docker pull 看到的层数不一样的源。 除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。 用 docker image ls 命令来配合像其它可以承接多个实体的命令一样，可以使用 docker image ls -q 来配合使用 docker image rm，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。 比如，我们需要删除所有仓库名为 redis 的镜像： 1$ docker image rm $(docker image ls -q redis) 或者删除所有在 mongo:3.2 之前的镜像： 1$ docker image rm $(docker image ls -q -f before=mongo:3.2) 充分利用你的想象力和 Linux 命令行的强大，你可以完成很多非常赞的功能。 CentOS/RHEL 的用户需要注意的事项在 Ubuntu/Debian 上有 UnionFS 可以使用，如 aufs 或者 overlay2，而 CentOS 和 RHEL 的内核中没有相关驱动。因此对于这类系统，一般使用 devicemapper 驱动利用 LVM 的一些机制来模拟分层存储。这样的做法除了性能比较差外，稳定性一般也不好，而且配置相对复杂。Docker 安装在 CentOS/RHEL 上后，会默认选择 devicemapper，但是为了简化配置，其 devicemapper 是跑在一个稀疏文件模拟的块设备上，也被称为 loop-lvm。这样的选择是因为不需要额外配置就可以运行 Docker，这是自动配置唯一能做到的事情。但是 loop-lvm 的做法非常不好，其稳定性、性能更差，无论是日志还是 docker info 中都会看到警告信息。官方文档有明确的文章讲解了如何配置块设备给 devicemapper 驱动做存储层的做法，这类做法也被称为配置 direct-lvm。 除了前面说到的问题外，devicemapper + loop-lvm 还有一个缺陷，因为它是稀疏文件，所以它会不断增长。用户在使用过程中会注意到 /var/lib/docker/devicemapper/devicemapper/data 不断增长，而且无法控制。很多人会希望删除镜像或者可以解决这个问题，结果发现效果并不明显。原因就是这个稀疏文件的空间释放后基本不进行垃圾回收的问题。因此往往会出现即使删除了文件内容，空间却无法回收，随着使用这个稀疏文件一直在不断增长。 所以对于 CentOS/RHEL 的用户来说，在没有办法使用 UnionFS 的情况下，一定要配置 direct-lvm 给 devicemapper，无论是为了性能、稳定性还是空间利用率。 或许有人注意到了 CentOS 7 中存在被 backports 回来的 overlay 驱动，不过 CentOS 里的这个驱动达不到生产环境使用的稳定程度，所以不推荐使用。 Dockerfile 定制镜像从刚才的 docker commit 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。 Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。 在一个空白目录中，建立一个文本文件，并命名为 Dockerfile： 123$ mkdir mynginx$ cd mynginx$ touch Dockerfile 其内容为： 12FROM nginxRUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html 这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。 FROM 指定基础镜像所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 在 Docker Store 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。 如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。 除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。 12FROM scratch... 如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。 不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 swarm、coreos/etcd。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。 RUN 执行命令RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种： shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。 1RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html exec 格式：RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]，这更像是函数调用中的格式。 既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样： 123456789FROM debian:jessieRUN apt-get updateRUN apt-get install -y gcc libc6-dev makeRUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install 之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。 而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。这是很多初学 Docker 的人常犯的一个错误。 Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。 上面的 Dockerfile 正确的写法应该是这样： 1234567891011121314FROM debian:jessieRUN buildDeps=&apos;gcc libc6-dev make&apos; \ &amp;&amp; apt-get update \ &amp;&amp; apt-get install -y $buildDeps \ &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \ &amp;&amp; mkdir -p /usr/src/redis \ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \ &amp;&amp; make -C /usr/src/redis \ &amp;&amp; make -C /usr/src/redis install \ &amp;&amp; rm -rf /var/lib/apt/lists/* \ &amp;&amp; rm redis.tar.gz \ &amp;&amp; rm -r /usr/src/redis \ &amp;&amp; apt-get purge -y --auto-remove $buildDeps 首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。 并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。 此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。 很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。 构建镜像好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。 在 Dockerfile 文件所在目录执行： 123456789$ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048 kBStep 1 : FROM nginx ---&gt; e43d811ce2f4Step 2 : RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html ---&gt; Running in 9cdc27646c7b ---&gt; 44aa4490ce2cRemoving intermediate container 9cdc27646c7bSuccessfully built 44aa4490ce2c 从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，如同我们之前所说的那样，RUN 指令启动了一个容器 9cdc27646c7b，执行了所要求的命令，并最后提交了这一层 44aa4490ce2c，随后删除了所用到的这个容器 9cdc27646c7b。 这里我们使用了 docker build 命令进行镜像构建。其格式为： 1docker build [选项] &lt;上下文路径/URL/-&gt; 在这里我们指定了最终镜像的名称 -t nginx:v3，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。 镜像构建上下文（Context）如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。那么什么是上下文呢？ 首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。 当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？ 这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。 如果在 Dockerfile 中这么写： 1COPY ./package.json /app/ 这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context）目录下的 package.json。 因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。 现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。 如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程： 123$ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048 kB... 理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。 一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。 那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile的文件作为 Dockerfile。 这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。 当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。 其它 docker build 的用法直接用 Git repo 进行构建或许你已经注意到了，docker build 还支持从 URL 构建，比如可以直接从 Git repo 中构建： 12345678$ docker build https://github.com/twang2218/gitlab-ce-zh.git#:8.14docker build https://github.com/twang2218/gitlab-ce-zh.git\#:8.14Sending build context to Docker daemon 2.048 kBStep 1 : FROM gitlab/gitlab-ce:8.14.0-ce.08.14.0-ce.0: Pulling from gitlab/gitlab-ceaed15891ba52: Already exists773ae8583d14: Already exists... 这行命令指定了构建所需的 Git repo，并且指定默认的 master 分支，构建目录为 /8.14/，然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。 用给定的 tar 压缩包构建1$ docker build http://server/context.tar.gz 如果所给出的 URL 不是个 Git repo，而是个 tar 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。 从标准输入中读取 Dockerfile 进行构建1docker build - &lt; Dockerfile 或 1cat Dockerfile | docker build - 如果标准输入传入的是文本文件，则将其视为 Dockerfile，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 COPY 进镜像之类的事情。 从标准输入中读取上下文压缩包进行构建1$ docker build - &lt; context.tar.gz 如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。 Dockerfile 指令详解###Dockerfile COPY 复制文件 格式： COPY &lt;源路径&gt;... &lt;目标路径&gt; COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;] 和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。 COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。比如： 1COPY package.json /usr/src/app/ &lt;源路径&gt; 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如： 12COPY hom* /mydir/COPY hom?.txt /mydir/ &lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。 此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。 Dockerfile ADD 更高级的复制文件ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。 比如 &lt;源路径&gt; 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。 如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。 在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 ubuntu 中： 123FROM scratchADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /... 但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 ADD 命令了。 在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。 另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。 因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。 ###Dockerfile CMD 容器启动命令 CMD 指令的格式和 RUN 相似，也是两种格式： shell 格式：CMD &lt;命令&gt; exec 格式：CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...] 参数列表格式：CMD [&quot;参数1&quot;, &quot;参数2&quot;...]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。 之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。 在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。 在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 &quot;，而不要使用单引号。 如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如： 1CMD echo $HOME 在实际执行中，会将其变更为： 1CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ] 这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。 提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。 Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。 一些初学者将 CMD 写为： 1CMD service nginx start 然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。 对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。 而使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服务。而刚才说了 CMD service nginx start 会被理解为 CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。 正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如： 1CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] Dockerfile ENTRYPOINT 入口点ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。 ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 --entrypoint 来指定。 当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为： 1&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot; 那么有了 CMD 后，为什么还要有 ENTRYPOINT 呢？这种 &lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot; 有什么好处么？让我们来看几个场景。 场景一：让镜像变成像命令一样使用假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现： 12345FROM ubuntu:16.04RUN apt-get update \ &amp;&amp; apt-get install -y curl \ &amp;&amp; rm -rf /var/lib/apt/lists/*CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ] 假如我们使用 docker build -t myip . 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行： 12$ docker run myip当前 IP：61.148.226.66 来自：北京市 联通 嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 CMD 中可以看到实质的命令是 curl，那么如果我们希望显示 HTTP 头信息，就需要加上 -i 参数。那么我们可以直接加 -i 参数给 docker run myip 么？ 12$ docker run myip -idocker: Error response from daemon: invalid header field value &quot;oci runtime error: container_linux.go:247: starting container process caused \&quot;exec: \\\&quot;-i\\\&quot;: executable file not found in $PATH\&quot;\n&quot;. 我们可以看到可执行文件找不到的报错，executable file not found。之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s http://ip.cn 后面。而 -i 根本不是命令，所以自然找不到。 那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令： 1$ docker run myip curl -s http://ip.cn -i 这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用 ENTRYPOINT 来实现这个镜像： 12345FROM ubuntu:16.04RUN apt-get update \ &amp;&amp; apt-get install -y curl \ &amp;&amp; rm -rf /var/lib/apt/lists/*ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ] 这次我们再来尝试直接使用 docker run myip -i： 123456789101112131415161718$ docker run myip当前 IP：61.148.226.66 来自：北京市 联通$ docker run myip -iHTTP/1.1 200 OKServer: nginx/1.8.0Date: Tue, 22 Nov 2016 05:12:40 GMTContent-Type: text/html; charset=UTF-8Vary: Accept-EncodingX-Powered-By: PHP/5.6.24-1~dotdeb+7.1X-Cache: MISS from cache-2X-Cache-Lookup: MISS from cache-2:80X-Cache: MISS from proxy-2_6Transfer-Encoding: chunkedVia: 1.1 cache-2:80, 1.1 proxy-2_6:8006Connection: keep-alive当前 IP：61.148.226.66 来自：北京市 联通 可以看到，这次成功了。这是因为当存在 ENTRYPOINT 后，CMD 的内容将会作为参数传给 ENTRYPOINT，而这里 -i 就是新的 CMD，因此会作为参数传给 curl，从而达到了我们预期的效果。 场景二：应用运行前的准备工作启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。 比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。 此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。 这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 &lt;CMD&gt;）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的： 12345678FROM alpine:3.4...RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis...ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]EXPOSE 6379CMD [ &quot;redis-server&quot; ] 可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 ENTRYPOINT 为 docker-entrypoint.sh 脚本。 123456789#!/bin/sh...# allow the container to be started with `--user`if [ &quot;$1&quot; = &apos;redis-server&apos; -a &quot;$(id -u)&quot; = &apos;0&apos; ]; then chown -R redis . exec su-exec redis &quot;$0&quot; &quot;$@&quot;fiexec &quot;$@&quot; 该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如： 12$ docker run -it redis iduid=0(root) gid=0(root) groups=0(root) Dockerfile ENV 设置环境变量格式有两种： ENV &lt;key&gt; &lt;value&gt; ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;... 这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。 12ENV VERSION=1.0 DEBUG=on \ NAME=&quot;Happy Feet&quot; 这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。 定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 node 镜像 Dockerfile 中，就有类似这样的代码： 123456789ENV NODE_VERSION 7.2.0RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot; \ &amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot; \ &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \ &amp;&amp; grep &quot; node-v$NODE_VERSION-linux-x64.tar.xz\$&quot; SHASUMS256.txt | sha256sum -c - \ &amp;&amp; tar -xJf &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; -C /usr/local --strip-components=1 \ &amp;&amp; rm &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; SHASUMS256.txt.asc SHASUMS256.txt \ &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs 在这里先定义了环境变量 NODE_VERSION，其后的 RUN 这层里，多次使用 $NODE_VERSION 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 7.2.0 即可，Dockerfile 构建维护变得更轻松了。 下列指令可以支持环境变量展开： ADD、COPY、ENV、EXPOSE、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD。 可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。 Dockerfile VOLUME 定义匿名卷格式为： VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...] VOLUME &lt;路径&gt; 之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。 1VOLUME /data 这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如： 1docker run -d -v mydata:/data xxxx 在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。 Dockerfile EXPOSE 暴露端口格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]。 EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 此外，在早期 Docker 版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个 Docker 引擎参数 --icc=false，当指定该参数后，容器间将默认无法互访，除非互相间使用了 --links 参数的容器才可以互通，并且只有镜像中 EXPOSE 所声明的端口才可以被访问。这个 --icc=false 的用法，在引入了 docker network 后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联与隔离。 要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 Dockerfile WORKDIR 指定工作目录格式为 WORKDIR &lt;工作目录路径&gt;。 使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。 之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误： 12RUN cd /appRUN echo &quot;hello&quot; &gt; world.txt 如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。 之前说过每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。 因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。 Dockerfile 参考文档 Dockerfie 官方文档：https://docs.docker.com/engine/reference/builder/ Dockerfile 最佳实践文档：https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/ Docker 官方镜像 Dockerfile：https://github.com/docker-library/docs 启动容器启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。 因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。 新建并启动所需要的命令主要为 docker run。 例如，下面的命令输出一个 “Hello World”，之后终止容器。 12$ docker run ubuntu:14.04 /bin/echo &apos;Hello world&apos;Hello world 这跟在本地直接执行 /bin/echo &#39;hello world&#39; 几乎感觉不出任何区别。 下面的命令则启动一个 bash 终端，允许用户进行交互。 12$ docker run -t -i ubuntu:14.04 /bin/bashroot@af8bae53bdd3:/# 其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。 在交互模式下，用户可以通过所创建的终端来输入命令，例如 1234root@af8bae53bdd3:/# pwd/root@af8bae53bdd3:/# lsbin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var 当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括： 检查本地是否存在指定的镜像，不存在就从公有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 启动已终止容器可以利用 docker container start 命令，直接将一个已经终止的容器启动运行。 容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 ps 或 top 来查看进程信息。 1234root@ba267838cc1b:/# ps PID TTY TIME CMD 1 ? 00:00:00 bash 11 ? 00:00:00 ps 可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。 终止容器可以使用 docker container stop 来终止一个运行中的容器。 此外，当 Docker 容器中指定的应用终结时，容器也自动终止。 例如对于上一章节中只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。 终止状态的容器可以用 docker container ls -a 命令看到。例如 1234docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESba267838cc1b ubuntu:14.04 &quot;/bin/bash&quot; 30 minutes ago Exited (0) About a minute ago trusting_newton98e5efa7d997 training/webapp:latest &quot;python app.py&quot; About an hour ago Exited (0) 34 minutes ago backstabbing_pike 处于终止状态的容器，可以通过 docker container start 命令来重新启动。 此外，docker container restart 命令会将一个运行态的容器终止，然后再重新启动它。 进入容器在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令，原因会在下面说明。 attach 命令docker attach 是 Docker 自带的命令。下面示例如何使用该命令。 123456789$ docker run -dit ubuntu243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550$ docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES243c32535da7 ubuntu:latest &quot;/bin/bash&quot; 18 seconds ago Up 17 seconds nostalgic_hypatia$ docker attach 243croot@243c32535da7:/# 注意： 如果从这个 stdin 中 exit，会导致容器的停止。 exec 命令-i -t 参数docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。 只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。 当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。 12345678910111213141516$ docker run -dit ubuntu69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6$ docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES69d137adef7a ubuntu:latest &quot;/bin/bash&quot; 18 seconds ago Up 17 seconds zealous_swirles$ docker exec -i 69d1 bashlsbinbootdev...$ docker exec -it 69d1 bashroot@69d137adef7a:/# 如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 docker exec 的原因。 更多参数说明请使用 docker exec --help 查看。 删除容器可以使用 docker container rm 来删除一个处于终止状态的容器。例如 12$ docker container rm trusting_newtontrusting_newton 如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。 清理所有处于终止状态的容器用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。 1$ docker container prune 访问 Docker 仓库仓库（Repository）是集中存放镜像的地方。 一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 dl.dockerpool.com/ubuntu 来说，dl.dockerpool.com 是注册服务器地址，ubuntu是仓库名。 大部分时候，并不需要严格区分这两者的概念。 Docker Hub目前 Docker 官方维护了一个公共仓库 Docker Hub，其中已经包括了数量超过 15,000 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。 注册你可以在 https://cloud.docker.com 免费注册一个 Docker 账号。 登录可以通过执行 docker login 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。 你可以通过 docker logout 退出登录。 拉取镜像你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。 例如以 centos 为关键词进行搜索： 1234567$ docker search centosNAME DESCRIPTION STARS OFFICIAL AUTOMATEDcentos The official build of CentOS. 465 [OK]tianon/centos CentOS 5 and 6, created using rinse instea... 28blalor/centos Bare-bones base CentOS 6.5 image 6 [OK]saltstack/centos-6-minimal 6 [OK]tutum/centos-6.4 DEPRECATED. Use tutum/centos:6.4 instead. ... 5 [OK] 可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建、是否自动创建。 官方的镜像说明是官方项目组创建和维护的，automated 资源允许用户验证镜像的来源和内容。 根据是否是官方提供，可将镜像资源分为两类。 一种是类似 centos 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。 还有一种类型，比如 tianon/centos 镜像，它是由 Docker 的用户创建并维护的，往往带有用户名称前缀。可以通过前缀 username/ 来指定使用某个用户提供的镜像，比如 tianon 用户。 另外，在查找的时候通过 --filter=stars=N 参数可以指定仅显示收藏数量为 N 以上的镜像。 下载官方 centos 镜像到本地。 123456$ docker pull centosPulling repository centos0b443ba03958: Download complete539c0211cd76: Download complete511136ea3c5a: Download complete7064731afe90: Download complete 推送镜像用户也可以在登录后通过 docker push 命令来将自己的镜像推送到 Docker Hub。 以下命令中的 username 请替换为你的 Docker 账号用户名。 1234567891011121314$ docker tag ubuntu:17.10 username/ubuntu:17.10$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEubuntu 17.10 275d79972a86 6 days ago 94.6MBusername/ubuntu 17.10 275d79972a86 6 days ago 94.6MB$ docker push username/ubuntu:17.10$ docker search usernameNAME DESCRIPTION STARS OFFICIAL AUTOMATEDusername/ubuntu 自动创建自动创建（Automated Builds）功能对于需要经常升级镜像内程序来说，十分方便。 有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。 而自动创建允许用户通过 Docker Hub 指定跟踪一个目标网站（目前支持 GitHub 或 BitBucket）上的项目，一旦项目发生新的提交或者创建新的标签（tag），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。 要配置自动创建，包括如下的步骤： 创建并登录 Docker Hub，以及目标网站； 在目标网站中连接帐户到 Docker Hub； 在 Docker Hub 中 配置一个自动创建； 选取一个目标网站中的项目（需要含 Dockerfile）和分支； 指定 Dockerfile 的位置，并提交创建。 之后，可以在 Docker Hub 的 自动创建页面 中跟踪每次创建的状态。 Docker 私有仓库有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。 本节介绍如何使用本地仓库。 docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 docker-registry v2.x 版本。 安装运行 docker-registry容器运行你可以通过获取官方 registry 镜像来运行。 1$ docker run -d -p 5000:5000 --restart=always --name registry registry 这将使用官方的 registry 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 /var/lib/registry 目录下。你可以通过 -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 /opt/data/registry 目录。 1234$ docker run -d \ -p 5000:5000 \ -v /opt/data/registry:/var/lib/registry \ registry 在私有仓库上传、搜索、下载镜像创建好私有仓库之后，就可以使用 docker tag 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 127.0.0.1:5000。 先在本机查看已有的镜像。 123$ docker image lsREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB 使用 docker tag 将 ubuntu:latest 这个镜像标记为 127.0.0.1:5000/ubuntu:latest。 格式为 docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]。 12345$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest$ docker image lsREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZEubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB127.0.0.1:5000/ubuntu:latest latest ba5877dc9bec 6 weeks ago 192.7 MB 使用 docker push 上传标记的镜像。 123456789$ docker push 127.0.0.1:5000/ubuntu:latestThe push refers to repository [127.0.0.1:5000/ubuntu]373a30c24545: Pusheda9148f5200b0: Pushedcdd3de0940ab: Pushedfc56279bbb33: Pushedb38367233d37: Pushed2aebd096e0e2: Pushedlatest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568 用 curl 查看仓库中的镜像。 12$ curl 127.0.0.1:5000/v2/_catalog&#123;&quot;repositories&quot;:[&quot;ubuntu&quot;]&#125; 这里可以看到 {&quot;repositories&quot;:[&quot;ubuntu&quot;]}，表明镜像已经被成功上传了。 先删除已有镜像，再尝试从私有仓库中下载这个镜像。 1234567891011121314$ docker image rm 127.0.0.1:5000/ubuntu:latest$ docker pull 127.0.0.1:5000/ubuntu:latestPulling repository 127.0.0.1:5000/ubuntu:latestba5877dc9bec: Download complete511136ea3c5a: Download complete9bad880da3d2: Download complete25f11f5fb0cb: Download completeebc34468f71d: Download complete2318d26665ef: Download complete$ docker image lsREPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE127.0.0.1:5000/ubuntu:latest latest ba5877dc9bec 6 weeks ago 192.7 MB 注意事项如果你不想使用 127.0.0.1:5000 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 192.168.199.100:5000 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。 这是因为 Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 HTTPS 访问的私有仓库。 Ubuntu 14.04, Debian 7 Wheezy对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS 中增加如下内容： 1DOCKER_OPTS=&quot;--registry-mirror=https://registry.docker-cn.com --insecure-registries=192.168.199.100:5000&quot; 重新启动服务。 1$ sudo service docker restart Ubuntu 16.04+, Debian 8+, centos 7对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件） 12345678&#123; &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot; ], &quot;insecure-registries&quot;: [ &quot;192.168.199.100:5000&quot; ]&#125; 注意：该文件必须符合 json 规范，否则 Docker 将不能启动。 其他对于 Docker for Windows 、 Docker for Mac 在设置中编辑 daemon.json 增加和上边一样的字符串即可。 数据卷数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性： 数据卷 可以在容器之间共享和重用 对 数据卷 的修改会立马生效 对 数据卷 的更新，不会影响镜像 数据卷 默认会一直存在，即使容器被删除 注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷。 选择 -v 还是 -–mount 参数Docker 新用户应该选择 --mount 参数，经验丰富的 Docker 使用者对 -v 或者 --volume 已经很熟悉了，但是推荐使用 --mount 参数。 创建一个数据卷1$ docker volume create my-vol 查看所有的 数据卷 123$ docker volume lslocal my-vol 在主机里使用以下命令可以查看指定 数据卷 的信息 1234567891011$ docker volume inspect my-vol[ &#123; &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: &#123;&#125;, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;, &quot;Name&quot;: &quot;my-vol&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Scope&quot;: &quot;local&quot; &#125;] 启动一个挂载数据卷的容器在用 docker run 命令的时候，使用 --mount 标记来将 数据卷 挂载到容器里。在一次 docker run 中可以挂载多个 数据卷。 下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。 123456$ docker run -d -P \ --name web \ # -v my-vol:/wepapp \ --mount source=my-vol,target=/webapp \ training/webapp \ python app.py 查看数据卷的具体信息在主机里使用以下命令可以查看 web 容器的信息 1$ docker inspect web 数据卷 信息在 “Mounts” Key 下面 123456789101112&quot;Mounts&quot;: [ &#123; &quot;Type&quot;: &quot;volume&quot;, &quot;Name&quot;: &quot;my-vol&quot;, &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;, &quot;Destination&quot;: &quot;/app&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;&quot; &#125;], 删除数据卷1$ docker volume rm my-vol 数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。 无主的数据卷可能会占据很多空间，要清理请使用以下命令 1$ docker volume prune Docker 构建 Tomcat查找 Docker Hub 上的 Tomcat 镜像123456789101112131415161718192021222324252627root@UbuntuBase:/usr/local/docker/tomcat# docker search tomcatNAME DESCRIPTION STARS OFFICIAL AUTOMATEDtomcat Apache Tomcat is an open source implementa... 1550 [OK] dordoka/tomcat Ubuntu 14.04, Oracle JDK 8 and Tomcat 8 ba... 43 [OK]tomee Apache TomEE is an all-Apache Java EE cert... 42 [OK] davidcaste/alpine-tomcat Apache Tomcat 7/8 using Oracle Java 7/8 wi... 21 [OK]consol/tomcat-7.0 Tomcat 7.0.57, 8080, &quot;admin/admin&quot; 16 [OK]cloudesire/tomcat Tomcat server, 6/7/8 15 [OK]maluuba/tomcat7 9 [OK]tutum/tomcat Base docker image to run a Tomcat applicat... 8 jeanblanchard/tomcat Minimal Docker image with Apache Tomcat 8 andreptb/tomcat Debian Jessie based image with Apache Tomc... 7 [OK]bitnami/tomcat Bitnami Tomcat Docker Image 5 [OK]aallam/tomcat-mysql Debian, Oracle JDK, Tomcat &amp; MySQL 4 [OK]antoineco/tomcat-mod_cluster Apache Tomcat with JBoss mod_cluster 1 [OK]maluuba/tomcat7-java8 Tomcat7 with java8. 1 amd64/tomcat Apache Tomcat is an open source implementa... 1 primetoninc/tomcat Apache tomcat 8.5, 8.0, 7.0 1 [OK]trollin/tomcat 0 fabric8/tomcat-8 Fabric8 Tomcat 8 Image 0 [OK]awscory/tomcat tomcat 0 oobsri/tomcat8 Testing CI Jobs with different names. 0 hegand/tomcat docker-tomcat 0 [OK]s390x/tomcat Apache Tomcat is an open source implementa... 0 ppc64le/tomcat Apache Tomcat is an open source implementa... 0 99taxis/tomcat7 Tomcat7 0 [OK]qminderapp/tomcat7 Tomcat 7 0 这里我们拉取官方的镜像 1docker pull tomcat 等待下载完成后，我们就可以在本地镜像列表里查到 REPOSITORY 为 tomcat 的镜像。 运行容器：1docker run --name tomcat -p 8080:8080 -v $PWD/test:/usr/local/tomcat/webapps/test -d tomcat 命令说明： -p 8080:8080：将容器的8080端口映射到主机的8080端口 -v $PWD/test:/usr/local/tomcat/webapps/test：将主机中当前目录下的test挂载到容器的/test 查看容器启动情况 123root@UbuntuBase:/usr/local/docker/tomcat/webapps# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES38498e53128c tomcat &quot;catalina.sh run&quot; 2 minutes ago Up 2 minutes 0.0.0.0:8080-&gt;8080/tcp tomcat 通过浏览器访问:192.168.75.129:8080 Docker 构建 MySQL查找 Docker Hub 上的 MySQL 镜像123456789101112131415161718192021222324252627root@UbuntuBase:/usr/local/docker/mysql# docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relati... 5177 [OK] mariadb MariaDB is a community-developed fork of M... 1602 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Crea... 361 [OK]percona Percona Server is a fork of the MySQL rela... 298 [OK] hypriot/rpi-mysql RPi-compatible Docker Image with Mysql 72 zabbix/zabbix-server-mysql Zabbix Server with MySQL database support 62 [OK]centurylink/mysql Image containing mysql. Optimized to be li... 53 [OK]sameersbn/mysql 48 [OK]zabbix/zabbix-web-nginx-mysql Zabbix frontend based on Nginx web-server ... 36 [OK]tutum/mysql Base docker image to run a MySQL database ... 27 1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5 ubuntu-16-nginx-php-phpmyadmin-mysql-5 17 [OK]schickling/mysql-backup-s3 Backup MySQL to S3 (supports periodic back... 16 [OK]centos/mysql-57-centos7 MySQL 5.7 SQL database server 15 linuxserver/mysql A Mysql container, brought to you by Linux... 12 centos/mysql-56-centos7 MySQL 5.6 SQL database server 6 openshift/mysql-55-centos7 DEPRECATED: A Centos7 based MySQL v5.5 ima... 6 frodenas/mysql A Docker Image for MySQL 3 [OK]dsteinkopf/backup-all-mysql backup all DBs in a mysql server 3 [OK]circleci/mysql MySQL is a widely used, open-source relati... 2 cloudposse/mysql Improved `mysql` service with support for ... 0 [OK]astronomerio/mysql-sink MySQL sink 0 [OK]ansibleplaybookbundle/rhscl-mysql-apb An APB which deploys RHSCL MySQL 0 [OK]cloudfoundry/cf-mysql-ci Image used in CI of cf-mysql-release 0 astronomerio/mysql-source MySQL source 0 [OK]jenkler/mysql Docker Mysql package 0 这里我们拉取官方的镜像 1docker pull mysql 等待下载完成后，我们就可以在本地镜像列表里查到 REPOSITORY 为 mysql 的镜像 运行容器：123456docker run -p 3306:3306 --name mysql \-v /usr/local/docker/mysql/conf:/etc/mysql \-v /usr/local/docker/mysql/logs:/var/log/mysql \-v /usr/local/docker/mysql/data:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=123456 \-d mysql 命令参数： -p 3306:3306：将容器的3306端口映射到主机的3306端口 -v /usr/local/docker/mysql/conf:/etc/mysql：将主机当前目录下的 conf 挂载到容器的 /etc/mysql -v /usr/local/docker/mysql/logs:/var/log/mysql：将主机当前目录下的 logs 目录挂载到容器的 /var/log/mysql -v /usr/local/docker/mysql/data:/var/lib/mysql：将主机当前目录下的 data 目录挂载到容器的 /var/lib/mysql -e MYSQL\_ROOT\_PASSWORD=123456：初始化root用户的密码 查看容器启动情况 123root@UbuntuBase:/usr/local/docker/mysql# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESbc49c9de4cdf mysql:latest &quot;docker-entrypoint...&quot; 4 minutes ago Up 4 minutes 0.0.0.0:3306-&gt;3306/tcp mysql 使用客户端工具连接 MySQL Docker 常用命令查看 Docker 版本1docker version 从 Docker 文件构建 Docker 映像1docker build -t image-name docker-file-location 运行 Docker 映像1docker run -d image-name 查看可用的 Docker 映像1docker images 查看最近的运行容器1docker ps -l 查看所有正在运行的容器1docker ps -a 停止运行容器1docker stop container_id 删除一个镜像1docker rmi image-name 删除所有镜像1docker rmi $(docker images -q) 强制删除所有镜像1docker rmi -r $(docker images -q) 删除所有为 的镜像1docker rmi $(docker images -q -f dangling=true) 删除所有容器1docker rm $(docker ps -a -q) 进入 Docker 容器1docker exec -it container-id /bin/bash 查看所有数据卷1docker volume ls 删除指定数据卷1docker volume rm [volume_name] 删除所有未关联的数据卷1docker volume rm $(docker volume ls -qf dangling=true) 从主机复制文件到容器1sudo docker cp host_path containerID:container_path 从容器复制文件到主机1sudo docker cp containerID:container_path host_path]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode]]></title>
    <url>%2F2018%2F08%2F12%2FLeetCode%2F</url>
    <content type="text"><![CDATA[1. 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] Java代码: 123456789101112public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int i=0,j = 0 ; for (i = 0; i &lt; nums.length; i++) &#123; for (j = i + 1; j &lt; nums.length; j++) &#123; if((nums[i]+nums[j]) == target) return new int[]&#123;i,j&#125; ; &#125; &#125; return null; &#125;&#125; 3. 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 Java代码: 123456789101112131415161718192021222324class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int x = 0; int y = 0; int length = 0; while (x &lt; n &amp;&amp; y &lt; n) &#123; // 如果set里面不包含个字符,那么就添加这个字符到set if (!set.contains(s.charAt(x))) &#123; set.add(s.charAt(x)); x++; // 没添加一次判断一下长度 length = Math.max(length,x - y); &#125; else &#123; // 如果set包含这个字符,此时y一直增加 直到删除到包含哪个字符的数为止 set.remove(s.charAt(y)); y++; &#125; &#125; return length; &#125;&#125; 7. 整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 12输入: 123输出: 321 示例 2: 12输入: -123输出: -321 示例 3: 12输入: 120输出: 21 Java代码: 123456789101112131415161718192021222324252627class Solution &#123; public int reverse(int x) &#123; String xString=String.valueOf(x); char[] chas=xString.toCharArray(); try &#123; if (Integer.valueOf(xString)&lt;0) &#123; for (int i = 1; i &lt;=chas.length/2; i++) &#123; char s=chas[i]; chas[i]=chas[chas.length-i]; chas[chas.length-i]=s; &#125; &#125; else &#123; for (int i = 0; i &lt; chas.length/2; i++) &#123; char s=chas[i]; chas[i]=chas[chas.length-i-1]; chas[chas.length-i-1]=s; &#125; &#125; String s=String.copyValueOf(chas); x=Integer.parseInt(s); return x; &#125; catch (Exception e) &#123; return 0; &#125; &#125;&#125; 9. 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 12输入: 121输出: true 示例 2: 123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 Java代码: 1234567891011121314151617181920212223class Solution &#123; public boolean isPalindrome(int x) &#123; // 特殊情况： // 如上所述，当 x &lt; 0 时，x 不是回文数。 // 同样地，如果数字的最后一位是 0，为了使该数字为回文， // 则其第一位数字也应该是 0 // 只有 0 满足这一属性 if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123; return false; &#125; int revertedNumber = 0; while(x &gt; revertedNumber) &#123; revertedNumber = revertedNumber * 10 + x % 10; x /= 10; &#125; // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x == revertedNumber || x == revertedNumber/10; &#125;&#125; 11. 盛最多水的容器给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 12输入: [1,8,6,2,5,4,8,3,7]输出: 49 Java代码: 123456789101112131415161718192021222324class Solution &#123; public int maxArea(int[] height) &#123; if(height.length == 2)&#123; return ((height[0] &gt; height[1])?height[1]:height[0]); &#125; //定义左指针x int x = 0; //定义右指针y int y = height.length-1; int maxarea = 0; //从左向右遍历 while(y &gt; 0)&#123; for(int i = 0; i &lt; y; i++)&#123; int maxheight = (height[i] &gt; height[y])?height[y]:height[i]; int area = (y - i)*maxheight; if(area &gt; maxarea)&#123; maxarea=area; &#125; &#125; y--; &#125; return maxarea; &#125;&#125; 14. 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2: 123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 Java代码: 12345678910111213141516171819202122public class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; int index = 0; if(strs.length ==0)&#123; return ""; &#125;else if(strs.length == 1)&#123; return strs[0]; &#125; for (int i = 0; i &lt; strs[0].length(); i++) &#123; //遍历第一个单词的字符 char c = strs[0].charAt(i); for (String str : strs) &#123; //遍历判断是否和其他单词的字符相等 if (str.length() == i || c != str.charAt(index)) &#123; return strs[0].substring(0,index); &#125; &#125; index++; &#125; return strs[0].substring(0); &#125;&#125; 26. 删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; Java代码: 123456789101112class Solution &#123; public int removeDuplicates(int[] nums) &#123; int n = 0; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[n] != nums[i]) &#123; n++; nums[n] = nums[i]; &#125; &#125; return n + 1; &#125;&#125; 27. 移除元素给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2: 1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; Java代码: 12345678910111213141516class Solution &#123; public int removeElement(int[] nums, int val) &#123; int i = 0; int length = nums.length; while (i &lt; length) &#123; //如果数组中的数等于val那么用最后一个数替换这个数同属数组长度-1 if (nums[i] == val) &#123; nums[i] = nums[length - 1]; length--; &#125; else &#123; i++; &#125; &#125; return length; &#125;&#125; 35. 搜索插入位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 12输入: [1,3,5,6], 5输出: 2 示例 2: 12输入: [1,3,5,6], 2输出: 1 示例 3: 12输入: [1,3,5,6], 7输出: 4 示例 4: 12输入: [1,3,5,6], 0输出: 0 Java代码: 1234567891011class Solution &#123; public int searchInsert(int[] nums, int target) &#123; if(nums == null) return 0; int i; for(i = 0; i &lt; nums.length; i++)&#123; if(nums[i] &gt;= target) return i; &#125; return i; &#125;&#125; 58. 最后一个单词的长度给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 12输入: &quot;Hello World&quot;输出: 5 Java代码: 123456789101112131415161718192021222324252627class Solution &#123; // public int lengthOfLastWord(String s) &#123; // int result = 0; // if(s.trim().isEmpty())&#123; // return 0; // &#125; // int length = s.length()-1; // for(int i = length;i&gt;0;i--)&#123; // if(s.charAt(i)==' ')&#123; // result = length-i; // &#125; // &#125; // return result; // &#125; public int lengthOfLastWord(String s) &#123; int length = 0; int i = s.length()-1; while(i&gt;=0 &amp;&amp; s.charAt(i)==' ') i--; while(i&gt;=0 &amp;&amp; s.charAt(i)!=' ')&#123; length++; i--; &#125; return length; &#125;&#125; 70. 爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 Java代码: 1234567891011121314class Solution &#123; public int climbStairs(int n) &#123; if (n &lt;= 2) &#123; return n; &#125; int pre2 = 1, pre1 = 2; for (int i = 2; i &lt; n; i++) &#123; int cur = pre1 + pre2; pre2 = pre1; pre1 = cur; &#125; return pre1; &#125;&#125; 141. 环形链表给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ Java代码: 123456789101112131415public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if (head == null || head.next == null) return false; ListNode fast = head; ListNode slow = head; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; if (slow == fast) return true; &#125; return false; &#125;&#125; 804. 唯一摩尔斯密码词国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: &quot;a&quot; 对应 &quot;.-&quot;, &quot;b&quot; 对应 &quot;-...&quot;, &quot;c&quot; 对应 &quot;-.-.&quot;, 等等。 为了方便，所有26个英文字母对应摩尔斯密码表如下： 1[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;] 给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，”cab” 可以写成 “-.-..–…”，(即 “-.-.” + “-…” + “.-“字符串的结合)。我们将这样一个连接过程称作单词翻译。 返回我们可以获得所有词不同单词翻译的数量。 1234567891011例如:输入: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]输出: 2解释: 各单词翻译如下:&quot;gin&quot; -&gt; &quot;--...-.&quot;&quot;zen&quot; -&gt; &quot;--...-.&quot;&quot;gig&quot; -&gt; &quot;--...--.&quot;&quot;msg&quot; -&gt; &quot;--...--.&quot;共有 2 种不同翻译, &quot;--...-.&quot; 和 &quot;--...--.&quot;. 注意: 单词列表words 的长度不会超过 100。 每个单词 words[i]的长度范围为 [1, 12]。 每个单词 words[i]只包含小写字母。 Java代码: 123456789101112131415import java.util.TreeSet;class Solution &#123; public int uniqueMorseRepresentations(String[] words) &#123; String[] codes = &#123;".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."&#125;; TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(); for(String word : words)&#123; StringBuffer sb = new StringBuffer(); for(int i = 0;i &lt; word.length(); i++) sb.append(codes[word.charAt(i) - 'a']); ts.add(sb.toString()); &#125; return ts.size(); &#125;&#125;]]></content>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2F2018%2F08%2F08%2FNginx%2F</url>
    <content type="text"><![CDATA[Nginx 简介什么是 NginxNginx 是一款高性能的 HTTP 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师 Igor Sysoev 所开发，官方测试 Nginx 能够支支撑 5 万并发链接，并且 CPU、内存等资源消耗却非常低，运行非常稳定。 Nginx 的应用场景 HTTP 服务器：Nginx 是一个 HTTP 服务可以独立提供 HTTP 服务。可以做网页静态服务器。 虚拟主机：可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 反向代理，负载均衡：当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 Nginx 做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 Nginx 虚拟主机我们使用 Docker 来安装和运行 Nginx，docker-compose.yml 配置如下： 1234567891011version: &apos;3.1&apos;services: nginx: restart: always image: nginx container_name: nginx ports: - 81:80 volumes: - ./conf/nginx.conf:/etc/nginx/nginx.conf - ./wwwroot:/usr/share/nginx/wwwroot 什么是虚拟主机？虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供 www 服务，这样就可以实现一台主机对外提供多个 web 服务，每个虚拟主机之间是独立的，互不影响的。 通过 Nginx 可以实现虚拟主机的配置，Nginx 支持三种类型的虚拟主机配置 基于 IP 的虚拟主机 基于域名的虚拟主机 基于端口的虚拟主机 Nginx 配置文件的结构12345678910111213141516# ...events &#123; # ...&#125;http &#123; # ... server&#123; # ... &#125; # ... server&#123; # ... &#125;&#125; 注： 每个 server 就是一个虚拟主机 基于端口的虚拟主机配置需求 Nginx 对外提供 80 和 8080 两个端口监听服务 请求 80 端口则请求 html80 目录下的 html 请求 8080 端口则请求 html8080 目录下的 html 创建目录及文件在 /usr/local/docker/nginx/wwwroot 目录下创建 html80 和 html8080 两个目录，并分辨创建两个 index.html 文件 配置虚拟主机修改 /usr/local/docker/nginx/conf 目录下的 nginx.conf 配置文件： 123456789101112131415161718192021222324252627282930313233343536373839404142worker_processes 1; #cpu内核数 老版本有惊群问题events &#123; worker_connections 1024; #每个子线程的连接数&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # 配置虚拟主机 192.168.75.145 server &#123; # 监听的ip和端口，配置 192.168.75.145:80 listen 80; # 虚拟主机名称这里配置ip地址 server_name 192.168.75.145; # 所有的请求都以 / 开始，所有的请求都可以匹配此 location location / &#123; # 使用 root 指令指定虚拟主机目录即网页存放目录 # 比如访问 http://ip/index.html 将找到 /usr/local/docker/nginx/wwwroot/html80/index.html # 比如访问 http://ip/item/index.html 将找到 /usr/local/docker/nginx/wwwroot/html80/item/index.html root /usr/share/nginx/wwwroot/html80; # 指定欢迎页面，按从左到右顺序查找 index index.html index.htm; &#125; &#125; # 配置虚拟主机 192.168.75.245 server &#123; listen 8080; server_name 192.168.75.145; location / &#123; root /usr/share/nginx/wwwroot/html8080; index index.html index.htm; &#125; &#125;&#125; 基于域名的虚拟主机配置需求 两个域名指向同一台 Nginx 服务器，用户访问不同的域名显示不同的网页内容 两个域名是 admin.service.itoken.funtl.com 和 admin.web.itoken.funtl.com Nginx 服务器使用虚拟机 192.168.75.145 配置 Windows Hosts 文件 通过 host 文件指定 admin.service.itoken.funtl.com 和 admin.web.itoken.funtl.com 对应 192.168.75.145 虚拟机： 修改 window 的 hosts 文件：（C:\Windows\System32\drivers\etc） 创建目录及文件在 /usr/local/docker/nginx/wwwroot 目录下创建 htmlservice 和 htmlweb 两个目录，并分辨创建两个 index.html 文件 配置虚拟主机12345678910111213141516171819202122232425262728293031323334user nginx;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name admin.service.itoken.funtl.com; location / &#123; root /usr/share/nginx/wwwroot/htmlservice; index index.html index.htm; &#125; &#125; server &#123; listen 80; server_name admin.web.itoken.funtl.com; location / &#123; root /usr/share/nginx/wwwroot/htmlweb; index index.html index.htm; &#125; &#125;&#125; Nginx 反向代理什么是代理服务器？代理服务器，客户机在发送请求时，不会直接发送给目的主机，而是先发送给代理服务器，代理服务接受客户机请求之后，再向主机发出，并接收目的主机返回的数据，存放在代理服务器的硬盘中，再发送给客户机。 为什么要使用代理服务器？提高访问速度由于目标主机返回的数据会存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到了缓存的作用，尤其对于热门站点能明显提高请求速度。 防火墙作用由于所有的客户机请求都必须通过代理服务器访问远程站点，因此可在代理服务器上设限，过滤某些不安全信息。 通过代理服务器访问不能访问的目标站点互联网上有许多开放的代理服务器，客户机在访问受限时，可通过不受限的代理服务器访问目标站点，通俗说，我们使用的翻墙浏览器就是利用了代理服务器，虽然不能出国，但也可直接访问外网。 什么是正向代理？正向代理，架设在客户机与目标主机之间，只用于代理内部网络对 Internet 的连接请求，客户机必须指定代理服务器,并将本来要直接发送到 Web 服务器上的 Http 请求发送到代理服务器中。 什么是反向代理？反向代理服务器架设在服务器端，通过缓冲经常被请求的页面来缓解服务器的工作量，将客户机请求转发给内部网络上的目标服务器；并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器与目标主机一起对外表现为一个服务器。 反向代理有哪些主要应用？现在许多大型 web 网站都用到反向代理。除了可以防止外网对内网服务器的恶性攻击、缓存以减少服务器的压力和访问安全控制之外，还可以进行负载均衡，将用户请求分配给多个服务器。 使用 Nginx 反向代理 Tomcat需求 两个 tomcat 服务通过 nginx 反向代理 nginx 服务器：192.168.75.145:80 tomcat1 服务器：192.168.75.145:9090 tomcat2 服务器：192.168.75.145:9091 启动 Tomcat 容器启动两个 Tomcat 容器，映射端口为 9090 和 9091，docker-compose.yml 如下： 12345678910111213version: &apos;3&apos;services: tomcat1: image: tomcat container_name: tomcat1 ports: - 9090:8080 tomcat2: image: tomcat container_name: tomcat2 ports: - 9091:8080 配置 Nginx 反向代理修改 /usr/local/docker/nginx/conf 目录下的 nginx.conf 配置文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748user nginx;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # 配置一个代理即 tomcat1 服务器 upstream tomcat_server1 &#123; server 192.168.75.145:9090; &#125; # 配置一个代理即 tomcat2 服务器 upstream tomcat_server2 &#123; server 192.168.75.145:9091; &#125; # 配置一个虚拟主机 server &#123; listen 80; server_name admin.service.itoken.funtl.com; location / &#123; # 域名 admin.service.itoken.funtl.com 的请求全部转发到 tomcat_server1 即 tomcat1 服务上 proxy_pass http://tomcat_server1; # 欢迎页面，按照从左到右的顺序查找页面 index index.jsp index.html index.htm; &#125; &#125; server &#123; listen 80; server_name admin.web.itoken.funtl.com; location / &#123; # 域名 admin.web.itoken.funtl.com 的请求全部转发到 tomcat_server2 即 tomcat2 服务上 proxy_pass http://tomcat_server2; index index.jsp index.html index.htm; &#125; &#125;&#125; Nginx 负载均衡什么是负载均衡负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。 负载均衡，英文名称为 Load Balance，其意思就是分摊到多个操作单元上进行执行，例如 Web 服务器、FTP 服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。 Nginx 实现负载均衡 nginx 作为负载均衡服务器，用户请求先到达 nginx，再由 nginx 根据负载配置将请求转发至 tomcat 服务器 nginx 负载均衡服务器：192.168.75.145:80 tomcat1 服务器：192.168.75.145:9090 tomcat2 服务器：192.168.75.145:9091 Nginx 配置负载均衡修改 /usr/local/docker/nginx/conf 目录下的 nginx.conf 配置文件： 1234567891011121314151617181920212223242526272829user nginx;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; upstream myapp1 &#123; server 192.168.75.145:9090 weight=10; server 192.168.75.145:9091 weight=10; &#125; server &#123; listen 80; server_name nginx.funtl.com; location / &#123; proxy_pass http://myapp1; index index.jsp index.html index.htm; &#125; &#125;&#125; 相关配置说明1234567# 定义负载均衡设备的 Ip及设备状态 upstream myServer &#123; server 127.0.0.1:9090 down; server 127.0.0.1:8080 weight=2; server 127.0.0.1:6060; server 127.0.0.1:7070 backup;&#125; 在需要使用负载的 Server 节点下添加 1proxy_pass http://myServer; upstream：每个设备的状态: down：表示当前的 server 暂时不参与负载 weight：默认为 1 weight 越大，负载的权重就越大。 max_fails：允许请求失败的次数默认为 1 当超过最大次数时，返回 proxy_next_upstream 模块定义的错误 fail_timeout:max_fails 次失败后，暂停的时间。 backup：其它所有的非 backup 机器 down 或者忙的时候，请求 backup 机器。所以这台机器压力会最轻 Nginx 配置说明配置文件区域Nginx 主要配置文件 nginx.conf，里面主要包括以下几个配置区域，如下表： 配置区域 说明 main 配置影响 nginx 全局的指令。一般有运行 nginx 服务器的用户组，nginx 进程 pid 存放路径，日志存放路径，配置文件引入，允许生成 worker process 数等。 events 配置影响 nginx 服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。 http 可以嵌套多个 server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type 定义，日志自定义，是否使用 sendfile 传输文件，连接超时时间，单连接请求数等。 upstream 配置 HTTP 负载均衡器分配流量到几个应用程序服务器。 server 配置虚拟主机的相关参数，一个 http 中可以有多个 server。 location 配置请求的路由，以及允许根据用户请求的URI来匹配指定的各 location 以进行访问配置；匹配到时，将被 location 块中的配置所处理 核心功能配置nginx 核心功能配置主要是 main 和 events 的顶层全局配置，都是配置 nginx 核心模块（ngx_core_module），管理服务器级别的行为。下表包含是大部分常用的配置选项，更多配置请参考官方文档：http://nginx.org/en/docs/ngx_core_module.html 配置类别 配置选项 上下文 语法 默认值 功能描述 基本配置 user main user username [groupname] nobody 以那个用户身份运行,以在configure指定的用户为准 pid main pid /path/to/pid_filename nginx.pid 指定nginx的pid文件 worker_rlimit_nofile main 受linux内核文件描述符数量限制 指定一个worker进程所能够打开的句柄数。因为Linux对每个进程所能打开的文件描述数量是有限制的，默认一般是1024个，可通过ulimit -n FILECNT或/etc/securit/limits.conf配置修改linux默认能打开的文件句柄数限制。建议值为：系统最大数量/进程数。但进程间工作量并不是平均分配的，所以可以设置在大一些。推荐值为：655350。 优化性能相关配置 worker_procrsses main **worker_processes number \ auto;** 1 work进程的个数.**如果负载以CPU密集型应用为主，一般会设置与机器cpu核数一致或少一个（用来处理用户等其他任务），如果负载以IO密集型为主，如响应大量内容给客户端，则worker数应该为CPU个数的1.5或2倍。因为更多的worker数，只会导致进程来竞争cpu资源了，从而带来不必要的上下文切换。而且，nginx为了更好的利用多核特性，具有cpu绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。** worker_cpu_affinity main worker_cpu_affinity cpumask …; 无，不绑定 将工作进程绑定到特定的CPU上，减少CPU在进程之间切换的开销。用二进制bit位表示进程绑定在哪个CPU内核。如4工作进程4内核：worker_processes 4;**worker_cpu_affinity 0001 0010 0100 1000;2工作进程4内核：worker_processes 2;**worker_cpu_affinity 0101 1010; worker_priority main worker_priority number; 0 工作进程调度优先级，-20到19之间的值，值越小越优先调用。如果系统同时运行多个任务，你可能需要提高nginx的工作进程的优先级 timer_resolution main timer_resolution interval; 无 每次内核事件调用返回时，都会使用gettimeday（）来更新nginx缓存时钟；timer_resolution用于定义每隔多久才会由gettimeday（）更新一次缓存时钟；x86-64系统上，gettimeday()代价已经很小，可以忽略此配置 ssl_engine main ssl_engine device; 无 在存在ssl硬件加速器的服务器上，指定所使用的ssl硬件加速设备。由于https链接所消耗的资源比http大得多，可能要多消耗5、6倍，最好有专门处理ssl的硬件设备 事件相关配置 worker_commections events worker_connections number; 512 每个worker能够并发响应的最大请求数。系统每处理一个请求就要消耗一个套接字文件，如果为代理服务器的话，worker_rlimit_nofile=worker_commections*2 use events use method; 无，自动选择 指定使用哪种模型（select/poll/epoll）,建议让nginx自动选择,**linux内核2.6以上一般能使用epoll，提高性能。** accept_mutex events **accept_mutex on \ off;** Off(1.11.3版本前默认on) 是否打开nginx的accept锁；此锁能够让多个worker进行轮流地、序列化地与新的客户端建立连接；而通常当一个worker进程的负载达到其上限的7/8，master就尽可能不将请求调度至worker.**1.11.3版本epoll支持EPOLLEXCLUSIVE 标记，不再有惊群问题 。** accept_mutex_delay events accept_mutex_delay time; 500ms 使用accept锁以后，只有一个worker能取得锁，一个worker进程为取得accept锁的等待时长，即用户建立等待的时间，如果某worker进程在某次试图取得锁时失败了，至少要等待#ms才能在一次请求锁 multi_accept events **multi_accept on \ off;** off 是否允许一次性地响应多个用户请求 调试、定位问题配置 daemon main **daemon on \ off;** on nginx是否以守护进程运行，是否让nignx运行于后台；调试时应该为off，使得所有信息直接输出在控制台 master_process main **master_process on \ off;** on 是否以master/worker模式运行nginx，默认为on，调试时可以设置为off以方便追踪 error_log main, http, mail, stream, server, location error_log file [level]; error_log logs/error.log error; 配置错误日志文件的路径和日志级别。日志级别有debug, info, notice, warn, error, crit, alert和emerg几种。调试时可以使用debug级别，但要求在编译时必须使用–with-debug启用debug功能，默认通常为error级别. HTTP 核心配置http 功能核心配置主要是 http 块、server 块和 location 块的配置，包括 HTTP 核心模块（ngx_http_core_module）和一些扩展模块（如ngx_stream_ssl_module），提供管理 WEB 服务器级别的行为。 必须使用虚拟机来配置站点，每个虚拟主机使用一个 server{} 段来配置，非虚拟主机的配置和公共选项，需要定义在 server 之外，http 之内。 下表包含是大部分常用的配置选项，更多配置请参考官方文档：http://nginx.org/en/docs/ 配置类别 配置选项/模块 上下文 语法 默认值 功能描述 基本配置 http main http { … } 无 提供HTTP服务器配置上下文 server http server { … } 无 HTTP服务器的核心配置，定义一个虚拟主机：nginx支持使用基于主机名或IP的虚拟主机 listen server listen address[:port]**listen prot**listen unix:socket **listen :80 \ :8000** 配置虚拟主机监听的IP地址和端口，默认监听本机IP地址和80或8000端口。如果只设置了IP没设端口，默认使用80端口。如果只设置了端口，没设置IP默认使用本机IP。**后面可以指定一些参数：default_server:定义此server为http中默认的server；如果所有的server中任何一个listen使用此参数，那么第一个server即为默认server；rcvbuf=SIZE：接收缓存大小；sndbuf=SIZE: 发送缓存大小；ssl：https server：必须以ssl连接；** server_name server server_name name …; “” 配置虚拟主机的域名，可以指定多个，用空格分隔。默认为空。**名称可以使用通配符和正则表达式（通常以~开头）：当nginx收到一个请求时，会取出其首部的server的值，而后跟众server_name进行比较：比较方式(1) 先做精确匹配，如www.tjiyu.com(2) 左侧通配符匹配，如tjiyu.com(3) 右侧通配符匹配，如www.(4) 正则表达式匹配** server_name_hash_bucket_size server server_names_hash_bucket_size size; **32\ 64\ 128** 为了实现快速主机查找，nginx使用hash表来保存主机名。**默认值取决于处理器缓存线的大小。** location server, location **location [ = \ ~ \ ~ \ ^~ ] uri { … }**location @name { … } 无 允许根据用户请求的URI来匹配指定的各location以进行访问配置；匹配到时，将被location块中的配置所处理。**=：精确匹配；~：正则表达式模式匹配，匹配时区分字符大小写；~：正则表达式模式匹配，匹配时忽略字符大小写；^~:只需要前半部分与uri匹配即可，不检查正则表达式；匹配优先级：**字符字面量最精确匹配、正则表达式检索（由多个时，由第一个匹配到的所处理），按字符字面量。 资源路径定义配置 root http, server, location, if in location root path; root html; 设置web资源路径，用于指定请求的根文档目录，从根开始匹配。**如root /html/image/，请求”/tjiyu.gif”对应的文件为”/html/image/tjiyu.gif”** alias location alias path; 无 指定路径别名，只能用于location中，从最后一个/开始匹配。**如location /i/ {alias /data/w3/images/;}**请求”/i/top.gif”, 实际文件”/data/w3/images/top.gif” Index http, server, location index file …; index index.html; ngx_http_index_module.**定义默认页面，可以跟多个值。自左向右匹配。** error_page http, server, location, if in location error_page code … [=[response]] uri; 无 ngx_http_core_module**当对于某个请求发回错误时，如果匹配上了error_page指令中设定的code，则从定向至新的URI中，错误重定向.如 error_page 500 502 503 504 /50x.html;也可以改变返回码。**如error_page 404 =200 /404.html; try_files server, location try_files file … uri;**try_files file … =code;** 无 自左向右尝试读取有path所指定路径，在第一找到即停止并返回，如果所有path均不存在，则返回最后一个uri或者code.**如try_files $uri $uri/index.html $uri.html =404;** 网络连接相关设置 keepalive_timeout http, server, location keepalive_timeout timeout [header_timeout]; 75s 保持连接的超时时长，默认为75s。**降低每个连接的alive时间可在一定程度上提高可响应连接数量，所以一般可适当降低此值** keepalive_requests http, server, location keepalive_requests number; 100 在一次长连接上允许承载的最大请求数。 keepalive_disable http, server, location **keepalive_disable none \ browser …;** msie6（ie6无法长连接） 对指定的浏览器禁止使用长连接。 tcp_nodelay http, server, location **tcp_nodelay on \ off;** on 这里指ngx_http_core_module模块的选项。**对keepalive连接是否使用tcp_nodelay选项**启动配置，会在数据包达到一定大小后再发送数据。这样会减少网络通信次数，降低阻塞概率，但也会影响响应及时性。比较适合于文件下载这类的大数据通信场景。 client_header_timeout http, server client_header_timeout time; 60s 读取http请求首部的超时时长。**如果客户端在此时间内未传输整个头，则会向客户端返回408（请求超时）错误。** client_body_timeout http, server, location client_body_timeout time; 60s 读取http请求包体的超时时间。 send_timeout http, server, location send_timeout time; 60s 发送响应的超时时长。**超时后连接将关闭。** 对客户端请求的限制配置 limit_except location limit_except method … { … } on 指定范围之外的其他方法的访问控制。**方法有：GET, HEAD, POST, PUT, DELETE, MKCOL, COPY, MOVE, OPTIONS, PROPFIND, PROPPATCH, LOCK, UNLOCK, or PATCH.如只允许GET访问：limit_except GET {allow 192.168.1.0/32;deny all;**} client_max_body_size http, server, location client_max_body_size size; 1m http请求包体的最大值，常用于限定客户端所能够请求的最大包体，根据请求首部中的Content-Length来检查，以避免无用的传输。 limit_rate http, server, location, if in location limit_rate rate; 0 限制客户端每秒传输的字节数，默认为0，表示没有限制。 limit_rate_after http, server, location, if in location limit_rate_after size; 0 nginx向客户端发送响应报文时，如果时长超过了此处指定的时长，则后续的发送过程开始限速（下载站点常用）。**配置上面的limit_rate使用。** 对客户端请求的特殊处理 ignore_invalid_headers http, server **ignore_invalid_headers on \ off;** on 是否忽略不合法的http首部，默认为on，off意味着请求首部中出现不合规的首部将拒绝响应。 log_not_found http, server, location **log_not_found on \ off;** on 用户访问的文件不存在时，是否将其记录到错误日志中。 resolver http, server, location **resolver address … [valid=time] [ipv6=on\ off];** 无 这里指ngx_http_core_module模块选项、**指定nginx使用的dns服务器地址。**valid = 30s，整缓存时间设置。在1.1.9版之前，不可能调整缓存时间，而nginx总是缓存答案5分钟的时间。 resolver_timeout http, server, location resolver_timeout time; 30s 指定DNS解析超时时长。 server_tokens http, server, location **server_tokens on \ off \ string;** on 是否在错误页面中显示和”响应头字段中发出nginx的版本号。**从版本1.9.13开始，可以使用带有变量的字符串显式设置。 空字符串禁用。** 文件操作的优化 sendfile http, server, location, if in location **sendfile on \ off;** off 是否启用sendfile内核复制模式功能。**作为静态服务器可以提高最大的IO访问速度。传统的文件读写采用read和write方式，流程为：硬盘 &gt;&gt; kernel buffer &gt;&gt; user buffer&gt;&gt; kernel socket buffer &gt;&gt;协议栈，采用sendfile文件读写的流程为：硬盘 &gt;&gt; kernel buffer (快速拷贝到kernelsocket buffer) &gt;&gt;协议栈，很明显sendfile这个系统调用减少了内核到用户模式之间的切换和数据拷贝次数，直接从内核缓存的数据拷贝到协议栈，提高了很大的效率。** aio http, server, location **aio on \ off \ threads[=pool];** off 是否启用异步文件IO功能。**Linux从内核版本2.6.22开始支持，有必要启用directio，否则读取将阻塞。directio只能用于读取在512字节边界（或XFS为4K）上对齐的块。文件结束未对齐将在阻塞模式下读取。当在Linux上同时启用AIO和sendfile功能时，AIO用于大于或等于directio指令中指定大小的文件，而小于或禁用directio时则用sendfile。location /video/ {sendfile on;aio on;directio 8m;**} open_file_cache http, server, location open_file_cache off;**open_file_cache max=N [inactive=time];** off 是否打开文件缓存功能。**max：用于缓存条目的最大值，允许打开的缓存条目最大数，当满两类以后将根据LRU（最小最少连接数）算法进行置换inactive：某缓存条目在指定时长内没有被访问过时，将自动被删除，即缓存有效期，通常默认为60s。缓存的信息包括： 文件句柄、文件大小和上次修改时间； 已经打开的目录结构；没有找到或没有访问权限的信息等。建议值：max=655350（和worker_rlimit_nofile参数一致） inactive=20s;** open_file_cache_errors http, server, location **open_file_cache_errors on \ off;** off 是否缓存文件找不到或没有权限访问等相关信息。 open_file_cache_valid http, server, location open_file_cache_valid time; 60s 多长时间检查一次缓存中的条目是否超出非活动时长。**建议值：小于等于open_file_cache inactive** open_file_cache_min_use http, server, location open_file_cache_min_uses number; 1 在open_file_cache inactive指定的时长内被访问超过此处指定的次数时，才不会被删除（删除低命中率的缓存）。 Gzip压缩相关配置 gzip http, server, location, if in location **gzip on \ off;** off 开启内容压缩，可以有效降低客户端的访问流量和网络带宽 gzip_min_length http, server, location gzip_min_length length; 20k 内容超过最少长度后才开启压缩，因为太短的内容压缩效果不佳，且压缩过程还会浪费系统资源。这个压缩长度会作为http响应头Content-Length字段返回给客户端。 建议值：64 gzip_comp_level http, server, location gzip_comp_level 1~9; 1 压缩级别，默认值为1。范围为1～9级，压缩级别越高压缩率越高，但对系统性能要求越高。**建议值：4** gzip_types http, server, location gzip_types mime-type …; text/html 压缩内容类型，默认为text/html;。只压缩html文本，一般我们都会压缩js、css、json之类的，可以把这些常见的文本数据都配上。如：text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf常用语法]]></title>
    <url>%2F2018%2F07%2F22%2FThymeleaf%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Thymeleaf 常用语法引入 Thymeleaf修改 html 标签用于引入 thymeleaf 引擎，这样才可以在其他标签里使用 th:* 语法，这是下面语法的前提。 12&lt;!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-spring4-4.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt; 获取变量值1&lt;p th:text="'Hello！, ' + $&#123;name&#125; + '!'" &gt;name&lt;/p&gt; 可以看出获取变量值用 $ 符号,对于javaBean的话使用 变量名.属性名 方式获取,这点和 EL 表达式一样. 另外 $ 表达式只能写在th标签内部,不然不会生效,上面例子就是使用 th:text 标签的值替换 p 标签里面的值,至于 p 里面的原有的值只是为了给前端开发时做展示用的.这样的话很好的做到了前后端分离. 引入 URLThymeleaf 对于 URL 的处理是通过语法 @{…} 来处理的 123&lt;a th:href="@&#123;http://www.baidu.com&#125;"&gt;绝对路径&lt;/a&gt;&lt;a th:href="@&#123;/&#125;"&gt;相对路径&lt;/a&gt;&lt;a th:href="@&#123;css/bootstrap.min.css&#125;"&gt;Content路径,默认访问static下的css文件夹&lt;/a&gt; 类似的标签有:th:href 和 th:src 字符串替换很多时候可能我们只需要对一大段文字中的某一处地方进行替换，可以通过字符串拼接操作完成： 1&lt;span th:text="'Welcome to our application, ' + $&#123;user.name&#125; + '!'"&gt; 一种更简洁的方式是： 1&lt;span th:text="|Welcome to our application, $&#123;user.name&#125;!|"&gt; 当然这种形式限制比较多，|…|中只能包含变量表达式${…}，不能包含其他常量、条件表达式等。 运算符在表达式中可以使用各类算术运算符，例如+, -, *, /, % 1th:with="isEven=($&#123;prodStat.count&#125; % 2 == 0)" 逻辑运算符&gt;, &lt;, &lt;=,&gt;=，==,!=都可以使用，唯一需要注意的是使用&lt;,&gt;时需要用它的HTML转义符： 12th:if="$&#123;prodStat.count&#125; &amp;gt; 1"th:text="'Execution mode is ' + ( ($&#123;execMode&#125; == 'dev')? 'Development' : 'Production')" 条件if/unlessThymeleaf 中使用 th:if 和 th:unless 属性进行条件判断，下面的例子中，标签只有在 th:if 中条件成立时才显示： 1&lt;a th:href=&quot;@&#123;/login&#125;&quot; th:unless=$&#123;session.user != null&#125;&gt;Login&lt;/a&gt; th:unless 于 th:if 恰好相反，只有表达式中的条件不成立，才会显示其内容。 switchThymeleaf 同样支持多路选择 Switch 结构： 1234&lt;div th:switch="$&#123;user.role&#125;"&gt; &lt;p th:case="'admin'"&gt;User is an administrator&lt;/p&gt; &lt;p th:case="#&#123;roles.manager&#125;"&gt;User is a manager&lt;/p&gt;&lt;/div&gt; 默认属性 default 可以用 * 表示： 12345&lt;div th:switch="$&#123;user.role&#125;"&gt; &lt;p th:case="'admin'"&gt;User is an administrator&lt;/p&gt; &lt;p th:case="#&#123;roles.manager&#125;"&gt;User is a manager&lt;/p&gt; &lt;p th:case="*"&gt;User is some other thing&lt;/p&gt;&lt;/div&gt; 循环渲染列表数据是一种非常常见的场景，例如现在有 n 条记录需要渲染成一个表格，该数据集合必须是可以遍历的，使用 th:each 标签： 1234567891011121314151617181920&lt;body&gt; &lt;h1&gt;Product list&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;th&gt;IN STOCK&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="prod : $&#123;prods&#125;"&gt; &lt;td th:text="$&#123;prod.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;prod.price&#125;"&gt;2.41&lt;/td&gt; &lt;td th:text="$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;"&gt;yes&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt; &lt;a href="../home.html" th:href="@&#123;/&#125;"&gt;Return to home&lt;/a&gt; &lt;/p&gt;&lt;/body&gt; 可以看到，需要在被循环渲染的元素（这里是）中加入 th:each 标签，其中 th:each=&quot;prod : ${prods}&quot; 意味着对集合变量 prods 进行遍历，循环变量是 prod在循环体中可以通过表达式访问。 使用文本 语法 说明 {home.welcome} 使用国际化文本,国际化传参直接追加 (value…) ${user.name} 使用会话属性 @{} 表达式中使用超链接 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot;href=&quot;../../css/gtvg.css&quot; th:href=&quot;@{/css/gtvg.css}&quot; /&gt; - - ${} 表达式中基本对象 param 获取请求参数，比如 ${param.name}, http://localhost:8080?name=jeff session 获取 session 的属性 application 获取 application 的属性 execInfo 有两个属性 templateName 和 now (是 java 的 Calendar 对象) ctx vars locale httpServletRequest httpSession - - th 扩展标签 th:text 普通字符串 th:utext 转义文本 th:href 链接 th:attr 设置元素属性 &lt;img src=&quot;../../images/gtvglogo.png&quot; th:attr=&quot;src=@{/images/gtvglogo.png},title=#{logo},alt=#{logo}&quot; /&gt; th:with 定义常量 th:attrappend 追加属性 th:classappend 追加类样式 th:styleappend 追加样式 Thymeleaf 其它 th 标签 语法 说明 th:abbr th:accept th:accept-charset th:accesskey th:action th:align th:alt th:archive th:audio th:autocomplete th:axis th:background th:bgcolor th:border th:cellpadding th:cellspacing th:challenge th:charset th:cite th:class th:classid th:codebase th:codetype th:cols th:colspan th:compact th:content th:contenteditable th:contextmenu th:data th:datetime th:dir th:draggable th:dropzone th:enctype th:for th:form th:formaction th:formenctype th:formmethod th:formtarget th:frame th:frameborder th:headers th:height th:high th:href th:hreflang th:hspace th:http-equiv th:icon th:id th:keytype th:kind th:label th:lang th:list th:longdesc th:low th:manifest th:marginheight th:marginwidth th:max th:maxlength th:media th:method th:min th:name th:optimum th:pattern th:placeholder th:poster th:preload th:radiogroup th:rel th:rev th:rows th:rowspan th:rules th:sandbox th:scheme th:scope th:scrolling th:size th:sizes th:span th:spellcheck th:src th:srclang th:standby th:start th:step th:style th:summary th:tabindex th:target th:title th:type th:usemap th:value th:valuetype th:vspace th:width th:wrap th:xmlbase th:xmllang th:xmlspace th:alt-title th:lang-xmllang 简单表达式语法#{...}Message 表达式 12&lt;p th:utext="#&#123;home.welcome($&#123;session.user.name&#125;)&#125;"&gt; Welcome to our grocery store, Sebastian Pepper!&lt;/p&gt;&lt;p th:utext="#&#123;$&#123;welcomeMsgKey&#125;($&#123;session.user.name&#125;)&#125;"&gt; Welcome to our grocery store, Sebastian Pepper!&lt;/p&gt; ${}变量表达式 1ongl 标准语法，方法也可以被调用 *{}选择变量表达式 12345678910111213141516171819202122&lt;div th:object="$&#123;session.user&#125;"&gt; &lt;p&gt;Name: &lt;span th:text="*&#123;firstName&#125;"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text="*&#123;lastName&#125;"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&#123;nationality&#125;"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 等价于&lt;div&gt; &lt;p&gt;Name: &lt;span th:text="$&#123;session.user.firstName&#125;"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text="$&#123;session.user.lastName&#125;"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text="$&#123;session.user.nationality&#125;"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt;当然了，这两者可以混合使用还有一种方式&lt;div&gt; &lt;p&gt;Name: &lt;span th:text="*&#123;session.user.name&#125;"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text="*&#123;session.user.surname&#125;"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text="*&#123;session.user.nationality&#125;"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; @{}链接 URL 表达式 123456789&lt;!-- Will produce &apos;http://localhost:8080/gtvg/order/details?orderId=3&apos; (plus rewriting) --&gt; &lt;a href=&quot;details.html&quot;th:href=&quot;@&#123;http://localhost:8080/gtvg/order/details(orderId=$&#123;o.id&#125;)&#125;&quot;&gt;view&lt;/a&gt; &lt;!-- Will produce &apos;/gtvg/order/details?orderId=3&apos; (plus rewriting) --&gt;&lt;a href=&quot;details.html&quot; th:href=&quot;@&#123;/order/details(orderId=$&#123;o.id&#125;)&#125;&quot;&gt;view&lt;/a&gt;&lt;!-- Will produce &apos;/gtvg/order/3/details&apos; (plus rewriting) --&gt;&lt;a href=&quot;details.html&quot; th:href=&quot;@&#123;/order/&#123;orderId&#125;/details(orderId=$&#123;o.id&#125;)&#125;&quot;&gt;view&lt;/a&gt; 变量 分类 实例 文本 one text，Another one!，… 数字 0 , 34 , 3.0 , 12.3 ,… 真假 true , false 文字符号 one , sometext , main ,… 算数运算 分类 实例 +, -, *, /, % 二元运算符 - 减号（一元运算符） 真假运算 分类 实例 and , or 二元运算符 ! , not 否定（一元运算符） 比较运算 分类 实例 &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le) 比较 == , != ( eq , ne ) 平等 条件运算 分类 实例 if-then (if) ? (then) if-then-else (if) ? (then) : (else) Default (value) ?: (defaultvalue) 内置对象#dates12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Dates* ======================================================================*//** Format date with the standard locale format* Also works with arrays, lists or sets*/$&#123;#dates.format(date)&#125;$&#123;#dates.arrayFormat(datesArray)&#125;$&#123;#dates.listFormat(datesList)&#125;$&#123;#dates.setFormat(datesSet)&#125;/** Format date with the ISO8601 format* Also works with arrays, lists or sets*/$&#123;#dates.formatISO(date)&#125;$&#123;#dates.arrayFormatISO(datesArray)&#125;$&#123;#dates.listFormatISO(datesList)&#125;$&#123;#dates.setFormatISO(datesSet)&#125;/** Format date with the specified pattern* Also works with arrays, lists or sets*/$&#123;#dates.format(date, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.arrayFormat(datesArray, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.listFormat(datesList, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.setFormat(datesSet, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;/** Obtain date properties* Also works with arrays, lists or sets*/$&#123;#dates.day(date)&#125; // also arrayDay(...), listDay(...), etc.$&#123;#dates.month(date)&#125; // also arrayMonth(...), listMonth(...), etc.$&#123;#dates.monthName(date)&#125; // also arrayMonthName(...), listMonthName(...), etc.$&#123;#dates.monthNameShort(date)&#125; // also arrayMonthNameShort(...), listMonthNameShort(...), etc.$&#123;#dates.year(date)&#125; // also arrayYear(...), listYear(...), etc.$&#123;#dates.dayOfWeek(date)&#125; // also arrayDayOfWeek(...), listDayOfWeek(...), etc.$&#123;#dates.dayOfWeekName(date)&#125; // also arrayDayOfWeekName(...), listDayOfWeekName(...), etc.$&#123;#dates.dayOfWeekNameShort(date)&#125; // also arrayDayOfWeekNameShort(...), listDayOfWeekNameShort(...), etc.$&#123;#dates.hour(date)&#125; // also arrayHour(...), listHour(...), etc.$&#123;#dates.minute(date)&#125; // also arrayMinute(...), listMinute(...), etc.$&#123;#dates.second(date)&#125; // also arraySecond(...), listSecond(...), etc.$&#123;#dates.millisecond(date)&#125; // also arrayMillisecond(...), listMillisecond(...), etc./** Create date (java.util.Date) objects from its components*/$&#123;#dates.create(year,month,day)&#125;$&#123;#dates.create(year,month,day,hour,minute)&#125;$&#123;#dates.create(year,month,day,hour,minute,second)&#125;$&#123;#dates.create(year,month,day,hour,minute,second)&#125;$&#123;#dates.create(year,month,day,hour,minute,second,millisecond)&#125;/** Create a date (java.util.Date) object for the current date and time*/$&#123;#dates.createNow()&#125;/** Create a date (java.util.Date) object for the current date (time set to 00:00)*/$&#123;#dates.createToday()&#125; #Calendars12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Calendars* ======================================================================*//** Format calendar with the standard locale format* Also works with arrays, lists or sets*/$&#123;#calendars.format(cal)&#125;$&#123;#calendars.arrayFormat(calArray)&#125;$&#123;#calendars.listFormat(calList)&#125;$&#123;#calendars.setFormat(calSet)&#125;/** Format calendar with the ISO8601 format* Also works with arrays, lists or sets*/$&#123;#calendars.formatISO(cal)&#125;$&#123;#calendars.arrayFormatISO(calArray)&#125;$&#123;#calendars.listFormatISO(calList)&#125;$&#123;#calendars.setFormatISO(calSet)&#125;/** Format calendar with the specified pattern* Also works with arrays, lists or sets*/$&#123;#calendars.format(cal, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#calendars.arrayFormat(calArray, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#calendars.listFormat(calList, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#calendars.setFormat(calSet, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;/** Obtain calendar properties* Also works with arrays, lists or sets*/$&#123;#calendars.day(date)&#125; // also arrayDay(...), listDay(...), etc.$&#123;#calendars.month(date)&#125; // also arrayMonth(...), listMonth(...), etc.$&#123;#calendars.monthName(date)&#125; // also arrayMonthName(...), listMonthName(...), etc.$&#123;#calendars.monthNameShort(date)&#125; // also arrayMonthNameShort(...), listMonthNameShort(...), etc.$&#123;#calendars.year(date)&#125; // also arrayYear(...), listYear(...), etc.$&#123;#calendars.dayOfWeek(date)&#125; // also arrayDayOfWeek(...), listDayOfWeek(...), etc.$&#123;#calendars.dayOfWeekName(date)&#125; // also arrayDayOfWeekName(...), listDayOfWeekName(...), etc.$&#123;#calendars.dayOfWeekNameShort(date)&#125; // also arrayDayOfWeekNameShort(...), listDayOfWeekNameShort(...), etc.$&#123;#calendars.hour(date)&#125; // also arrayHour(...), listHour(...), etc.$&#123;#calendars.hour(date)&#125; // also arrayHour(...), listHour(...), etc.$&#123;#calendars.minute(date)&#125; // also arrayMinute(...), listMinute(...), etc.$&#123;#calendars.second(date)&#125; // also arraySecond(...), listSecond(...), etc.$&#123;#calendars.millisecond(date)&#125; // also arrayMillisecond(...), listMillisecond(...), etc./** Create calendar (java.util.Calendar) objects from its components*/$&#123;#calendars.create(year,month,day)&#125;$&#123;#calendars.create(year,month,day,hour,minute)&#125;$&#123;#calendars.create(year,month,day,hour,minute,second)&#125;$&#123;#calendars.create(year,month,day,hour,minute,second,millisecond)&#125;/** Create a calendar (java.util.Calendar) object for the current date and time*/$&#123;#calendars.createNow()&#125;/** Create a calendar (java.util.Calendar) object for the current date (time set to 00:00)*/$&#123;#calendars.createToday()&#125; #numbers1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Numbers* ======================================================================*//** ==========================* Formatting integer numbers* ==========================*//** Set minimum integer digits.* Also works with arrays, lists or sets*/$&#123;#numbers.formatInteger(num,3)&#125;$&#123;#numbers.arrayFormatInteger(numArray,3)&#125;$&#123;#numbers.listFormatInteger(numList,3)&#125;$&#123;#numbers.setFormatInteger(numSet,3)&#125;/** Set minimum integer digits and thousands separator:* &apos;POINT&apos;, &apos;COMMA&apos;, &apos;WHITESPACE&apos;, &apos;NONE&apos; or &apos;DEFAULT&apos; (by locale).* Also works with arrays, lists or sets*/$&#123;#numbers.formatInteger(num,3,&apos;POINT&apos;)&#125;$&#123;#numbers.arrayFormatInteger(numArray,3,&apos;POINT&apos;)&#125;$&#123;#numbers.listFormatInteger(numList,3,&apos;POINT&apos;)&#125;$&#123;#numbers.setFormatInteger(numSet,3,&apos;POINT&apos;)&#125;/** ==========================* Formatting decimal numbers* ==========================*//** Set minimum integer digits and (exact) decimal digits.* Also works with arrays, lists or sets*/$&#123;#numbers.formatDecimal(num,3,2)&#125;$&#123;#numbers.arrayFormatDecimal(numArray,3,2)&#125;$&#123;#numbers.listFormatDecimal(numList,3,2)&#125;$&#123;#numbers.setFormatDecimal(numSet,3,2)&#125;/** Set minimum integer digits and (exact) decimal digits, and also decimal separator.* Also works with arrays, lists or sets*/$&#123;#numbers.formatDecimal(num,3,2,&apos;COMMA&apos;)&#125;$&#123;#numbers.arrayFormatDecimal(numArray,3,2,&apos;COMMA&apos;)&#125;$&#123;#numbers.listFormatDecimal(numList,3,2,&apos;COMMA&apos;)&#125;$&#123;#numbers.setFormatDecimal(numSet,3,2,&apos;COMMA&apos;)&#125;/** Set minimum integer digits and (exact) decimal digits, and also thousands and* decimal separator.* Also works with arrays, lists or sets*/$&#123;#numbers.formatDecimal(num,3,&apos;POINT&apos;,2,&apos;COMMA&apos;)&#125;$&#123;#numbers.arrayFormatDecimal(numArray,3,&apos;POINT&apos;,2,&apos;COMMA&apos;)&#125;$&#123;#numbers.listFormatDecimal(numList,3,&apos;POINT&apos;,2,&apos;COMMA&apos;)&#125;$&#123;#numbers.setFormatDecimal(numSet,3,&apos;POINT&apos;,2,&apos;COMMA&apos;)&#125;/** ==========================* Utility methods* ==========================*//** Create a sequence (array) of integer numbers going* from x to y*/$&#123;#numbers.sequence(from,to)&#125;$&#123;#numbers.sequence(from,to,step)&#125; #strings123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Strings* ======================================================================*//** Null-safe toString()*/$&#123;#strings.toString(obj)&#125; // also array*, list* and set*/** Check whether a String is empty (or null). Performs a trim() operation before check* Also works with arrays, lists or sets* * Also works with arrays, lists or sets*/$&#123;#strings.isEmpty(name)&#125;$&#123;#strings.arrayIsEmpty(nameArr)&#125;$&#123;#strings.listIsEmpty(nameList)&#125;$&#123;#strings.setIsEmpty(nameSet)&#125;/** Perform an &apos;isEmpty()&apos; check on a string and return it if false, defaulting to* another specified string if true.* Also works with arrays, lists or sets*/$&#123;#strings.defaultString(text,default)&#125;$&#123;#strings.arrayDefaultString(textArr,default)&#125;$&#123;#strings.listDefaultString(textList,default)&#125;$&#123;#strings.setDefaultString(textSet,default)&#125;/** Check whether a fragment is contained in a String* Also works with arrays, lists or sets*/$&#123;#strings.contains(name,&apos;ez&apos;)&#125; // also array*, list* and set*$&#123;#strings.containsIgnoreCase(name,&apos;ez&apos;)&#125; // also array*, list* and set*/** Check whether a String starts or ends with a fragment* Also works with arrays, lists or sets*/$&#123;#strings.startsWith(name,&apos;Don&apos;)&#125; // also array*, list* and set*$&#123;#strings.endsWith(name,endingFragment)&#125; // also array*, list* and set*/** Substring-related operations* Also works with arrays, lists or sets*/$&#123;#strings.indexOf(name,frag)&#125; // also array*, list* and set*$&#123;#strings.substring(name,3,5)&#125; // also array*, list* and set*$&#123;#strings.substringAfter(name,prefix)&#125; // also array*, list* and set*$&#123;#strings.substringBefore(name,suffix)&#125; // also array*, list* and set*$&#123;#strings.replace(name,&apos;las&apos;,&apos;ler&apos;)&#125; // also array*, list* and set*/** Append and prepend* Also works with arrays, lists or sets*/$&#123;#strings.prepend(str,prefix)&#125; // also array*, list* and set*$&#123;#strings.append(str,suffix)&#125; // also array*, list* and set*/** Change case* Also works with arrays, lists or sets*/$&#123;#strings.toUpperCase(name)&#125; // also array*, list* and set*$&#123;#strings.toLowerCase(name)&#125; // also array*, list* and set*/** Split and join*/$&#123;#strings.arrayJoin(namesArray,&apos;,&apos;)&#125;$&#123;#strings.listJoin(namesList,&apos;,&apos;)&#125;$&#123;#strings.setJoin(namesSet,&apos;,&apos;)&#125;$&#123;#strings.arraySplit(namesStr,&apos;,&apos;)&#125; // returns String[]$&#123;#strings.listSplit(namesStr,&apos;,&apos;)&#125; // returns List&lt;String&gt;$&#123;#strings.setSplit(namesStr,&apos;,&apos;)&#125; // returns Set&lt;String&gt;/** Trim* Also works with arrays, lists or sets*/$&#123;#strings.trim(str)&#125; // also array*, list* and set*/** Compute length* Also works with arrays, lists or sets*/$&#123;#strings.length(str)&#125; // also array*, list* and set*/** Abbreviate text making it have a maximum size of n. If text is bigger, it* will be clipped and finished in &quot;...&quot;* Also works with arrays, lists or sets*/$&#123;#strings.abbreviate(str,10)&#125; // also array*, list* and set*/** Convert the first character to upper-case (and vice-versa)*/$&#123;#strings.capitalize(str)&#125; // also array*, list* and set*$&#123;#strings.unCapitalize(str)&#125; // also array*, list* and set*/** Convert the first character of every word to upper-case*/$&#123;#strings.capitalizeWords(str)&#125; // also array*, list* and set*$&#123;#strings.capitalizeWords(str,delimiters)&#125; // also array*, list* and set*/** Escape the string*/$&#123;#strings.escapeXml(str)&#125; // also array*, list* and set*$&#123;#strings.escapeJava(str)&#125; // also array*, list* and set*$&#123;#strings.escapeJavaScript(str)&#125; // also array*, list* and set*$&#123;#strings.unescapeJava(str)&#125; // also array*, list* and set*$&#123;#strings.unescapeJavaScript(str)&#125; // also array*, list* and set*/** Null-safe comparison and concatenation*/$&#123;#strings.equals(first, second)&#125;$&#123;#strings.equalsIgnoreCase(first, second)&#125;$&#123;#strings.concat(values...)&#125;$&#123;#strings.concatReplaceNulls(nullValue, values...)&#125;/** Random*/$&#123;#strings.randomAlphanumeric(count)&#125; #objects12345678910111213/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Objects* ======================================================================*//** Return obj if it is not null, and default otherwise* Also works with arrays, lists or sets*/$&#123;#objects.nullSafe(obj,default)&#125;$&#123;#objects.arrayNullSafe(objArray,default)&#125;$&#123;#objects.listNullSafe(objList,default)&#125;$&#123;#objects.setNullSafe(objSet,default)&#125; #bools123456789101112131415161718192021222324252627282930313233343536/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Bools* ======================================================================*//** Evaluate a condition in the same way that it would be evaluated in a th:if tag* (see conditional evaluation chapter afterwards).* Also works with arrays, lists or sets*/$&#123;#bools.isTrue(obj)&#125;$&#123;#bools.arrayIsTrue(objArray)&#125;$&#123;#bools.listIsTrue(objList)&#125;$&#123;#bools.setIsTrue(objSet)&#125;/** Evaluate with negation* Also works with arrays, lists or sets*/$&#123;#bools.isFalse(cond)&#125;$&#123;#bools.arrayIsFalse(condArray)&#125;$&#123;#bools.listIsFalse(condList)&#125;$&#123;#bools.setIsFalse(condSet)&#125;/** Evaluate and apply AND operator* Receive an array, a list or a set as parameter*/$&#123;#bools.arrayAnd(condArray)&#125;$&#123;#bools.listAnd(condList)&#125;$&#123;#bools.setAnd(condSet)&#125;/** Evaluate and apply OR operator* Receive an array, a list or a set as parameter*/$&#123;#bools.arrayOr(condArray)&#125;$&#123;#bools.listOr(condList)&#125;$&#123;#bools.setOr(condSet)&#125; #arrays12345678910111213141516171819202122232425262728293031323334/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Arrays* ======================================================================*//** Converts to array, trying to infer array component class.* Note that if resulting array is empty, or if the elements* of the target object are not all of the same class,* this method will return Object[].*/$&#123;#arrays.toArray(object)&#125;/** Convert to arrays of the specified component class.*/$&#123;#arrays.toStringArray(object)&#125;$&#123;#arrays.toIntegerArray(object)&#125;$&#123;#arrays.toLongArray(object)&#125;$&#123;#arrays.toDoubleArray(object)&#125;$&#123;#arrays.toFloatArray(object)&#125;$&#123;#arrays.toBooleanArray(object)&#125;/** Compute length*/$&#123;#arrays.length(array)&#125;/** Check whether array is empty*/$&#123;#arrays.isEmpty(array)&#125;/** Check if element or elements are contained in array*/$&#123;#arrays.contains(array, element)&#125;$&#123;#arrays.containsAll(array, elements)&#125; #lists12345678910111213141516171819202122232425262728/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Lists* ======================================================================*//** Converts to list*/$&#123;#lists.toList(object)&#125;/** Compute size*/$&#123;#lists.size(list)&#125;/** Check whether list is empty*/$&#123;#lists.isEmpty(list)&#125;/** Check if element or elements are contained in list*/$&#123;#lists.contains(list, element)&#125;$&#123;#lists.containsAll(list, elements)&#125;/** Sort a copy of the given list. The members of the list must implement* comparable or you must define a comparator.*/$&#123;#lists.sort(list)&#125;$&#123;#lists.sort(list, comparator)&#125; #sets12345678910111213141516171819202122/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Sets* ======================================================================*//** Converts to set*/$&#123;#sets.toSet(object)&#125;/** Compute size*/$&#123;#sets.size(set)&#125;/** Check whether set is empty*/$&#123;#sets.isEmpty(set)&#125;/** Check if element or elements are contained in set*/$&#123;#sets.contains(set, element)&#125;$&#123;#sets.containsAll(set, elements)&#125; #maps1234567891011121314151617181920/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Maps* ======================================================================*//** Compute size*/$&#123;#maps.size(map)&#125;/** Check whether map is empty*/$&#123;#maps.isEmpty(map)&#125;/** Check if key/s or value/s are contained in maps*/$&#123;#maps.containsKey(map, key)&#125;$&#123;#maps.containsAllKeys(map, keys)&#125;$&#123;#maps.containsValue(map, value)&#125;$&#123;#maps.containsAllValues(map, value)&#125; #aggregates123456789101112131415/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Aggregates* ======================================================================*//** Compute sum. Returns null if array or collection is empty*/$&#123;#aggregates.sum(array)&#125;$&#123;#aggregates.sum(collection)&#125;/** Compute average. Returns null if array or collection is empty*/$&#123;#aggregates.avg(array)&#125;$&#123;#aggregates.avg(collection)&#125; #messages12345678910111213141516171819202122232425262728293031/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Messages* ======================================================================*//** Obtain externalized messages. Can receive a single key, a key plus arguments,* or an array/list/set of keys (in which case it will return an array/list/set of* externalized messages).* If a message is not found, a default message (like &apos;??msgKey??&apos;) is returned.*/$&#123;#messages.msg(&apos;msgKey&apos;)&#125;$&#123;#messages.msg(&apos;msgKey&apos;, param1)&#125;$&#123;#messages.msg(&apos;msgKey&apos;, param1, param2)&#125;$&#123;#messages.msg(&apos;msgKey&apos;, param1, param2, param3)&#125;$&#123;#messages.msgWithParams(&apos;msgKey&apos;, new Object[] &#123;param1, param2, param3, param4&#125;)&#125;$&#123;#messages.arrayMsg(messageKeyArray)&#125;$&#123;#messages.listMsg(messageKeyList)&#125;$&#123;#messages.setMsg(messageKeySet)&#125;/** Obtain externalized messages or null. Null is returned instead of a default* message if a message for the specified key is not found.*/$&#123;#messages.msgOrNull(&apos;msgKey&apos;)&#125;$&#123;#messages.msgOrNull(&apos;msgKey&apos;, param1)&#125;$&#123;#messages.msgOrNull(&apos;msgKey&apos;, param1, param2)&#125;$&#123;#messages.msgOrNull(&apos;msgKey&apos;, param1, param2, param3)&#125;$&#123;#messages.msgOrNullWithParams(&apos;msgKey&apos;, new Object[] &#123;param1, param2, param3, param4&#125;)&#125;$&#123;#messages.arrayMsgOrNull(messageKeyArray)&#125;$&#123;#messages.listMsgOrNull(messageKeyList)&#125;$&#123;#messages.setMsgOrNull(messageKeySet)&#125; #ids1234567891011121314151617181920/** ======================================================================* See javadoc API for class org.thymeleaf.expression.Ids* ======================================================================*//** Normally used in th:id attributes, for appending a counter to the id attribute value* so that it remains unique even when involved in an iteration process.*/$&#123;#ids.seq(&apos;someId&apos;)&#125;/** Normally used in th:for attributes in &lt;label&gt; tags, so that these labels can refer to Ids* generated by means if the #ids.seq(...) function.** Depending on whether the &lt;label&gt; goes before or after the element with the #ids.seq(...)* function, the &quot;next&quot; (label goes before &quot;seq&quot;) or the &quot;prev&quot; function (label goes after* &quot;seq&quot;) function should be called.*/$&#123;#ids.next(&apos;someId&apos;)&#125;$&#123;#ids.prev(&apos;someId&apos;)&#125; Thymeleaf 循环123456789101112131415161718&lt;tr th:each=&quot;prod : $&#123;prods&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;/td&gt; &lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;/td&gt; &lt;td th:text=&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;/td&gt;&lt;/tr&gt;&lt;table&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;PRICE&lt;/th&gt; &lt;th&gt;IN STOCK&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;prod,iterStat : $&#123;prods&#125;&quot; th:class=&quot;$&#123;iterStat.odd&#125;? &apos;odd&apos;&quot;&gt; &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;/td&gt; &lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;/td&gt; &lt;td th:text=&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 迭代器的状态： index: 当前的索引，从0开始 count: 当前的索引，从1开始 size：总数 current: even/odd: first last 判断if1&lt;a href=&quot;comments.html&quot; th:href=&quot;@&#123;/product/comments(prodId=$&#123;prod.id&#125;)&#125;&quot; th:if=&quot;$&#123;not #lists.isEmpty(prod.comments)&#125;&quot;&gt;view&lt;/a&gt; unless1&lt;a href=&quot;comments.html&quot; th:href=&quot;@&#123;/comments(prodId=$&#123;prod.id&#125;)&#125;&quot; th:unless=&quot;$&#123;#lists.isEmpty(prod.comments)&#125;&quot;&gt;view&lt;/a&gt; switch1234567&lt;div th:switch=&quot;$&#123;user.role&#125;&quot;&gt; &lt;p th:case=&quot;&apos;admin&apos;&quot;&gt;User is an administrator&lt;/p&gt; &lt;p th:case=&quot;#&#123;roles.manager&#125;&quot;&gt;User is a manager&lt;/p&gt;&lt;/div&gt;&lt;div th:switch=&quot;$&#123;user.role&#125;&quot;&gt; &lt;p th:case=&quot;&apos;admin&apos;&quot;&gt;User is an administrator&lt;/p&gt; &lt;p th:case=&quot;#&#123;roles.manager&#125;&quot;&gt;User is a manager&lt;/p&gt; &lt;p th:case=&quot;*&quot;&gt;User is some other thing&lt;/p&gt;&lt;/div&gt; 模板布局模板模块导入首先定义一个 /resources/templates/footer.html 文件： 12345678&lt;!DOCTYPE html SYSTEM &quot;http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;body&gt; &lt;div th:fragment=&quot;copy&quot;&gt; &amp;copy; 2018 Copyright by mirrorming. &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 上面的代码定义了一个片段称为 copy，我们可以很容易地使用 th:include 或者 th:replace 属性包含在我们的主页上 1234&lt;body&gt;...&lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;/body&gt; include 的表达式想当简洁。这里有三种写法： templatename::domselector 或者 templatename::[domselector] 引入模板页面中的某个模块 templatename 引入模板页面 ::domselector 或者 this::domselector 引入自身模板的模块 上面所有的 templatename 和 domselector 的写法都支持表达式写法： 1&lt;div th:include=&quot;footer :: ($&#123;user.isAdmin&#125;? #&#123;footer.admin&#125; : #&#123;footer.normaluser&#125;)&quot;&gt;&lt;/div&gt; 不使用 th:fragment 来引用模块123&lt;div id=&quot;copy-section&quot;&gt;&amp;copy; 2018 Copyright by mirrorming.&lt;/div&gt; 我们可以用 CSS 的选择器写法来引入 1234&lt;body&gt;...&lt;div th:include=&quot;footer :: #copy-section&quot;&gt;&lt;/div&gt;&lt;/body&gt; th:include 和 th:replace 的区别th:include 和 th:replace 都可以引入模块，两者的区别在于： th:include：引入子模块的 children，依然保留父模块的 tag th:replace：引入子模块的所有，不保留父模块的 tag 举个例子123&lt;footer th:fragment=&quot;copy&quot;&gt;&amp;copy; 2018 Copyright by mirrorming.&lt;/footer&gt; 引入界面12345&lt;body&gt;...&lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;/body&gt; 显示结果123456789&lt;body&gt;...&lt;div&gt;&amp;copy; 2018 Copyright by mirrorming.&lt;/div&gt;&lt;footer&gt;&amp;copy; 2018 Copyright by mirrorming.&lt;/footer&gt;&lt;/body&gt; Thymeleaf th:blockth:block 用法12345678910&lt;table&gt; &lt;th:block th:each=&quot;user : $&#123;users&#125;&quot;&gt; &lt;tr&gt; &lt;td th:text=&quot;$&#123;user.login&#125;&quot;&gt;...&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.name&#125;&quot;&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; th:text=&quot;$&#123;user.address&#125;&quot;&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;/th:block&gt;&lt;/table&gt; 推荐下面写法（编译前看不见） 123456789&lt;table&gt; &lt;tr&gt; &lt;td th:text="$&#123;user.login&#125;"&gt;...&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" th:text="$&#123;user.address&#125;"&gt;...&lt;/td&gt; &lt;/tr&gt; &lt;!--/*/ &lt;/th:block&gt; /*/--&gt; &lt;/table&gt; Thymeleaf th:inlineth:inline 用法th:inline 可以等于 text , javascript(dart) , none text: [[…]]1&lt;p th:inline=&quot;text&quot;&gt;Hello, [[#&#123;test&#125;]]&lt;/p&gt; javascript: /[[…]]/12345678910111213141516171819&lt;script th:inline=&quot;javascript&quot;&gt; var username = /*[[ #&#123;test&#125; ]]*/; var name = /*[[ $&#123;param.name[0]&#125;+$&#123;execInfo.templateName&#125;+&apos;-&apos;+$&#123;#dates.createNow()&#125;+&apos;-&apos;+$&#123;#locale&#125; ]]*/;&lt;/script&gt;&lt;script th:inline=&quot;javascript&quot;&gt;/*&lt;![CDATA[*/ var username = [[#&#123;test&#125;]]; var name = [[$&#123;param.name[0]&#125;+$&#123;execInfo.templateName&#125;+&apos;-&apos;+$&#123;#dates.createNow()&#125;+&apos;-&apos;+$&#123;#locale&#125;]];/*]]&gt;*/&lt;/script&gt; adding code: /* [+…+]*/12345var x = 23;/*[+var msg = &apos;Hello, &apos; + [[$&#123;session.user.name&#125;]]; +]*/var f = function() &#123;... removind code: /[- / and /* -]*/12345var x = 23;/*[- */var msg = &apos;This is a non-working template&apos;; /* -]*/var f = function() &#123;...]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写SpringMVC]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%89%8B%E5%86%99springMVC%2F</url>
    <content type="text"><![CDATA[手写springMVC注解版实现 springMVC原理:http://www.mirrorming.cn/article/aeb6988401744bceb82b0b95060059d2 pom文件12345678910111213141516171819202122232425262728&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.mirrorming&lt;/groupId&gt; &lt;artifactId&gt;springMVCdemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provide&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 项目结构 核心类DispatcherServlet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201package cn.mirrorming.springMVCdemo.framework.servlet;import java.io.File;import java.io.IOException;import java.lang.annotation.Annotation;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.net.URL;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import cn.mirrorming.springMVCdemo.framework.annotation.MirrorAutowired;import cn.mirrorming.springMVCdemo.framework.annotation.MirrorController;import cn.mirrorming.springMVCdemo.framework.annotation.MirrorRequestMapping;import cn.mirrorming.springMVCdemo.framework.annotation.MirrorRequestParam;import cn.mirrorming.springMVCdemo.framework.annotation.MirrorService;/** * @author mirror * */public class DispatcherServlet extends HttpServlet &#123; // 保存所有扫描包的list List&lt;String&gt; classNames = new ArrayList&lt;&gt;(); // 创建一个容器map保存注解后面的值为key,对象为value Map&lt;String, Object&gt; beans = new HashMap&lt;&gt;(); // 创建一个容器map存放路径方法 Map&lt;String, Object&gt; handlerMap = new HashMap&lt;&gt;(); // &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;由于web.xml中配置了此项,tomcat启动时会先执行这个方法 public void init(ServletConfig servletConfig) &#123; // 1.扫描cn.mirrorming.mirrorming_springMVCdemo.controller doScan(&quot;cn.mirrorming&quot;); // 2.实例化 doInstance(); // 3.注入 doAutowired(); // 4.匹配路径 urlMapping();// 路径/controller/select--&gt;method &#125; public void urlMapping() &#123; for (Map.Entry&lt;String, Object&gt; entry : beans.entrySet()) &#123; Object instance = entry.getValue(); Class&lt;?&gt; clazz = instance.getClass(); if (clazz.isAnnotationPresent(MirrorController.class)) &#123; MirrorRequestMapping requestMapping = clazz.getAnnotation(MirrorRequestMapping.class); String classPath = requestMapping.value(); // 获得类路径 /controller Method[] methods = clazz.getMethods(); for (Method method : methods) &#123; if (method.isAnnotationPresent(MirrorRequestMapping.class)) &#123; MirrorRequestMapping request = method.getAnnotation(MirrorRequestMapping.class); String methodPath = request.value(); handlerMap.put(classPath + methodPath, method); &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125; // 注入 public void doAutowired() &#123; for (Map.Entry&lt;String, Object&gt; entry : beans.entrySet()) &#123; Object instance = entry.getValue(); Class&lt;?&gt; clazz = instance.getClass(); if (clazz.isAnnotationPresent(MirrorController.class)) &#123; Field[] fields = clazz.getFields(); // Annotation[] annotations = clazz.getAnnotations(); for (Field field : fields) &#123; if (field.isAnnotationPresent(MirrorAutowired.class)) &#123; MirrorAutowired autowired = field.getAnnotation(MirrorAutowired.class); String key = autowired.value(); Object value = beans.get(key); field.setAccessible(true); try &#123; field.set(instance, value); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; continue; &#125; &#125; &#125; // 实例化并添加到容器 public void doInstance() &#123; for (String className : classNames) &#123; String cn = className.replace(&quot;.class&quot;, &quot;&quot;); try &#123; Class&lt;?&gt; clazz = Class.forName(cn); if (clazz.isAnnotationPresent(MirrorController.class)) &#123; Object controllerInstance = clazz.newInstance();// 实例化对象 // map.put(key,instance); MirrorRequestMapping mapping = clazz.getAnnotation(MirrorRequestMapping.class); String controllerKey = mapping.value(); beans.put(controllerKey, controllerInstance); &#125; else if (clazz.isAnnotationPresent(MirrorService.class)) &#123; Object serviceInstance = clazz.newInstance();// 实例化对象 // map.put(key,instance); MirrorService mapping = clazz.getAnnotation(MirrorService.class); String serviceKey = mapping.value(); beans.put(serviceKey, serviceInstance); &#125; else &#123; continue; &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // 扫描包 public void doScan(String basePackage) &#123; // 扫描编译好的所有类路径 // 将cn.mirrorming变成cn/mirrorming URL url = this.getClass().getClassLoader().getResource(&quot;/&quot; + basePackage.replaceAll(&quot;\\.&quot;, &quot;/&quot;)); // URL url = this.getClass().getClassLoader().getResource(&quot;/&quot;); String fileStr = (url.getFile()).substring(1).replaceAll(&quot;\\%[20]+&quot;, &quot; &quot;); // cn.mirror File file = new File(fileStr);// 得到文件对象 String[] filesStr = file.list();// 得到文件夹下所有.class for (String path : filesStr) &#123; File filePath = new File(fileStr + path);// cn/mirrorming/mirrorming_springMVCdemo if (filePath.isDirectory()) &#123; doScan(basePackage + &quot;.&quot; + path); &#125; else &#123; // 找到class类 cn/mirrorming/mirrorming_springMVCdemo/.../xxx.class classNames.add(basePackage + &quot;.&quot; + filePath.getName()); &#125; &#125; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 获取到请求路径 String uri = req.getRequestURI(); // 项目名/controller/select String context = req.getContextPath(); // 项目名 String path = uri.replace(context, &quot;&quot;); // /controller/select---&gt;key Method method = (Method) handlerMap.get(path); // /controller/select---&gt;method Object args[] = hand(req, resp, method); Object instance = beans.get(&quot;/myController&quot;); try &#123; method.invoke(instance, args); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; // super.doPost(req, resp); &#125; public static Object[] hand(HttpServletRequest request, HttpServletResponse response, Method method) &#123; // 拿到当前执行的方法有哪些参数 Class&lt;?&gt;[] paramClazzs = method.getParameterTypes(); // 根据参数的个数,new一个参数的数组,将方法里的所有参数赋值到args来 Object[] args = new Object[paramClazzs.length]; int args_i = 0; int index = 0; for (Class&lt;?&gt; paramClazz : paramClazzs) &#123; if (ServletRequest.class.isAssignableFrom(paramClazz)) &#123; args[args_i++] = request; &#125; if (ServletResponse.class.isAssignableFrom(paramClazz)) &#123; args[args_i++] = response; &#125; // 从0-3判断有没有requestParam注解,很明显paramClazz为0和1时,不是 // 当为2和3为requestParam,需要解析 Annotation[] paramAns = method.getParameterAnnotations()[index]; if (paramAns.length &gt; 0) &#123; for (Annotation paramAn : paramAns) &#123; if (MirrorRequestParam.class.isAssignableFrom(paramAn.getClass())) &#123; MirrorRequestParam rp = (MirrorRequestParam) paramAn; String value = rp.value(); // 找到注解里的name和age args[args_i++] = request.getParameter(rp.value()); &#125; &#125; &#125; index++; &#125; return args; &#125;&#125; 用到的5个注解123456789101112131415161718192021222324252627282930313233343536================================================================@Documented@Retention(RUNTIME)@Target(ElementType.TYPE)public @interface MirrorController &#123; String value() default &quot;&quot;;&#125;================================================================@Documented@Retention(RUNTIME)@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)public @interface MirrorRequestMapping &#123; String value() default &quot;&quot;;&#125;================================================================@Documented@Retention(RUNTIME)@Target(ElementType.PARAMETER)public @interface MirrorRequestParam &#123; String value() default &quot;&quot;;&#125;================================================================@Documented@Retention(RUNTIME)@Target(ElementType.TYPE)public @interface MirrorService &#123; String value() default &quot;&quot;;&#125;================================================================@Documented@Retention(RUNTIME)@Target(ElementType.FIELD)public @interface MirrorAutowired &#123; String value() default &quot;&quot;;&#125;================================================================ service和imp类1234567891011public interface IMirrorSercice &#123; String select(String name, String age);&#125;================================================================@MirrorService(&quot;MirrorService&quot;)public class MirrorServiceImp implements IMirrorSercice &#123; @Override public String select(String name, String age) &#123; return &quot;name:&quot; + name + &quot;,age:&quot; + age; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2018%2F07%2F11%2FLinux%2F</url>
    <content type="text"><![CDATA[Linux 简介Linux 是一种自由和开放源码的类 UNIX 操作系统，使用 Linux 内核。目前存在着许多不同的 Linux 发行版，可安装在各种各样的电脑硬件设备，从手机、平板电脑、路由器和影音游戏控制台，到桌上型电脑，大型电脑和超级电脑。 Linux 是一个领先的操作系统，世界上运算最快的 10 台超级电脑运行的都是 Linux 操作系统。 Linux 操作系统也是自由软件和开放源代码发展中最著名的例子。只要遵循 GNU 通用公共许可证,任何人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。严格来讲，Linux 这个词本身只表示 Linux 内核，但在实际上人们已经习惯了用 Linux 来形容整个基于 Linux 内核，并且使用 GNU 工程各种工具和数据库的操作系统 (也被称为 GNU/ Linux)。通常情况下，Linux 被打包成供桌上型电脑和服务器使用的 Linux 发行版本。一些流行的主流 Linux 发行版本，包括 Debian (及其衍生版本 Ubuntu)，Fedora 和 OpenSUSE 等。Kernel + Softwares + Tools 就是 Linux Distribution 目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare等。 Linux 与 Windows 比较 目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下 比较 Windows Linux 界面 界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同 图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 UNIX 传承下来，基本命令和操作方法也几乎一致。 驱动程序 驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。 由志愿者开发，由Linux核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在 Windows 下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。 使用 使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。 图形界面使用简单，容易入门。文字界面，需要学习才能掌握。 学习 系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。 系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。 软件 每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。 大部分软件都可以自由获取，同样功能的软件选择较少。 Linux 的目录结构 目录 说明 bin 存放二进制可执行文件(ls,cat,mkdir等) boot 存放用于系统引导时使用的各种文件 dev 用于存放设备文件 etc 存放系统配置文件 home 存放所有用户文件的根目录 lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt 系统管理员安装临时文件系统的安装点 opt 额外安装的可选应用程序包所放置的位置 proc 虚拟文件系统，存放当前内存的映射 root 超级用户目录 sbin 存放二进制可执行文件，只有root才能访问 tmp 用于存放各种临时文件 usr 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录 var 用于存放运行时需要改变数据的文件 Linux 操作文件目录 命令 说明 语法 参数 参数说明 ls 显示文件和目录列表 ls [-alrtAFR] [name…] -l 列出文件的详细信息 -a 列出当前目录所有文件，包含隐藏文件 mkdir 创建目录 mkdir [-p] dirName -p 父目录不存在情况下先生成父目录 cd 切换目录 cd [dirName] touch 生成一个空文件 echo 生成一个带内容文件 echo abcd &gt; 1.txt，echo 1234 &gt;&gt; 1.txt cat 显示文本文件内容 cat [-AbeEnstTuv] [–help] [–version] fileName cp 复制文件或目录 cp [options] source dest rm 删除文件 rm [options] name… -f 强制删除文件或目录 -r 同时删除该目录下的所有文件 mv 移动文件或目录 mv [options] source dest find 在文件系统中查找指定的文件 -name 文件名 grep 在指定的文本文件中查找指定的字符串 tree 用于以树状图列出目录的内容 pwd 显示当前工作目录 ln 建立软链接 more 分页显示文本文件内容 head 显示文件开头内容 tail 显示文件结尾内容 -f 跟踪输出 Linux 系统管理命令 命令 说明 stat 显示指定文件的相关信息,比ls命令显示内容更多 who 显示在线登录用户 hostname 显示主机名称 uname 显示系统信息 top 显示当前系统中耗费资源最多的进程 ps 显示瞬间的进程状态 du 显示指定的文件（目录）已使用的磁盘空间的总量 df 显示文件系统磁盘空间的使用情况 free 显示当前内存和交换空间的使用情况 ifconfig 显示网络接口信息 ping 测试网络的连通性 netstat 显示网络状态信息 clear 清屏 kill 杀死一个进程 Linux 开关机命令shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。 命令 语法 参数 参数说明 shutdown shutdown [-t seconds] [-rkhncfF] time [message] -t seconds 设定在几秒钟之后进行关机程序 -k 并不会真的关机，只是将警告讯息传送给所有只用者 -r 关机后重新开机（重启） -h 关机后停机 -n 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机 -c 取消目前已经进行中的关机动作 -f 关机时，不做 fcsk 动作(检查 Linux 档系统) -F 关机时，强迫进行 fsck 动作 time 设定关机的时间 message 传送给所有使用者的警告讯息 重启 reboot shutdown -r now 关机 shutdown -h now Linux 压缩命令tar 命令 语法 参数 参数说明 tar tar [-cxzjvf] 压缩打包文档的名称 欲打包目录 -c 建立一个归档文件的参数指令 -x 解开一个归档文件的参数指令 -z 是否需要用 gzip 压缩 -j 是否需要用 bzip2 压缩 -v 压缩的过程中显示文件 -f 使用档名，在 f 之后要立即接档名 -tf 查看归档文件里面的文件 例子： 压缩文件夹：tar -zcvf test.tar.gz test\ 解压文件夹：tar -zxvf test.tar.gz gzip 命令 语法 参数 参数说明 gzip gzip [选项] 压缩（解压缩）的文件名 -d 解压缩 -l 对每个压缩文件，显示压缩文件的大小，未压缩文件的大小，压缩比，未压缩文件的名字 -v 对每一个压缩和解压的文件，显示文件名和压缩比 -num 用指定的数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比）。系统缺省值为6 说明：压缩文件后缀为 gz bzip2 命令 语法 参数 参数说明 bzip2 bzip2 [-cdz] -d 解压缩 -z 压缩参数 -num 用指定的数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比）。系统缺省值为6 说明：压缩文件后缀为 bz2 Linux 编辑器vim运行模式编辑模式：等待编辑命令输入 插入模式：编辑模式下，输入 i 进入插入模式，插入文本信息 命令模式：在编辑模式下，输入 : 进行命令模式 命令:q 直接退出vi :wq 保存后退出vi ，并可以新建文件 :q! 强制退出 :w file 将当前内容保存成某个文件 :set number 在编辑文件显示行号 :set nonumber 在编辑文件不显示行号 nanonano 是一个字符终端的文本编辑器，有点像 DOS 下的 editor 程序。它比 vi/vim 要简单得多，比较适合 Linux 初学者使用。某些 Linux 发行版的默认编辑器就是 nano。 命令 保存：ctrl + o 搜索：ctrl + w 上一页：ctrl + y 下一页：ctrl + v 退出：ctrl + x Linux 软件包管理APT(Advanced Packaging Tool) 是 Debian/Ubuntu 类 Linux 系统中的软件包管理程序, 使用它可以找到想要的软件包, 而且安装、卸载、更新都很简便；也可以用来对 Ubuntu 进行升级; APT 的源文件为 /etc/apt/ 目录下的 sources.list 文件。 修改数据源由于国内的网络环境问题，我们需要将 Ubuntu 的数据源修改为国内数据源，操作步骤如下： 查看系统版本1lsb_release -a 输出结果为 12345No LSB modules are available.Distributor ID: UbuntuDescription: Ubuntu 16.04 LTSRelease: 16.04Codename: xenial 注意： Codename 为 xenial，该名称为我们 Ubuntu 系统的名称，修改数据源需要用到该名称 编辑数据源1vi /etc/apt/sources.list 删除全部内容并修改为 1234deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse 更新数据源1apt-get update 常用 APT 命令安装软件包1apt-get install packagename 删除软件包1apt-get remove packagename 更新软件包列表1apt-get update 升级有可用更新的系统（慎用）1apt-get upgrade 其它 APT 命令搜索1apt-cache search package 获取包信息1apt-cache show package 删除包及配置文件1apt-get remove package --purge 了解使用依赖1apt-cache depends package 查看被哪些包依赖1apt-cache rdepends package 安装相关的编译环境1apt-get build-dep package 下载源代码1apt-get source package 清理无用的包1apt-get clean &amp;&amp; apt-get autoclean 检查是否有损坏的依赖1apt-get check Linux 用户和组管理Linux 操作系统是一个多用户操作系统，它允许多用户同时登录到系统上并使用资源。系统会根据账户来区分每个用户的文件，进程，任务和工作环境，使得每个用户工作都不受干扰。 使用 Root 用户在实际生产操作中，我们基本上都是使用超级管理员账户操作 Linux 系统，也就是 Root 用户，Linux 系统默认是关闭 Root 账户的，我们需要为 Root 用户设置一个初始密码以方便我们使用。 设置 Root 账户密码1sudo passwd root 切换到 Root1su 设置允许远程登录 Root12345678910nano /etc/ssh/sshd_config# Authentication:LoginGraceTime 120#PermitRootLogin without-password //注释此行PermitRootLogin yes //加入此行StrictModes yes重启服务service ssh restart 用户账户说明普通用户普通用户在系统上的任务是进行普通操作 超级管理员管理员在系统上的任务是对普通用户和整个系统进行管理。对系统具有绝对的控制权，能够对系统进行一切操作。用 root 表示，root 用户在系统中拥有最高权限，默认下 Ubuntu 用户的 root 用户是不能登录的。 安装时创建的系统用户此用户创建时被添加到 admin 组中，在 Ubuntu 中，admin 组中的用户默认是可以使用 sudo 命令来执行只有管理员才能执行的命令的。如果不使用 sudo 就是一个普通用户。 组账户说明私有组当创建一个用户时没有指定属于哪个组，Linux 就会建立一个与用户同名的私有组，此私有组只含有该用户。 标准组当创建一个用户时可以选定一个标准组，如果一个用户同时属于多个组时，登录后所属的组为主组，其他的为附加组。 账户系统文件说明/etc/passwd每一行代表一个账号，众多账号是系统正常运行所必须的，例如 bin，nobody 每行定义一个用户账户，此文件对所有用户可读。每行账户包含如下信息： 1root:x:0:0:root:/root:/bin/bash 用户名： 就是账号，用来对应 UID，root UID 是 0。 口令： 密码，早期 UNIX 系统密码存在此字段，由于此文件所有用户都可以读取，密码容易泄露，后来这个字段数据就存放到 /etc/shadow 中，这里只能看到 X。 用户标示号（UID）： 系统内唯一，root 用户的 UID 为 0，普通用户从 1000 开始，1-999 是系统的标准账户，500-65536 是可登陆账号。 组标示号（GID）： 与 /etc/group 相关用来规定组名和 GID 相对应。 注释： 注释账号 宿主目录（主文件夹）： 用户登录系统后所进入的目录 root 在 /root/itcast 命令解释器（shell）： 指定该用户使用的 shell ，默认的是 /bin/bash /etc/shadow为了增加系统的安全性，用户口令通常用 shadow passwords 保护。只有 root 可读。每行包含如下信息： 1root:$6$Reu571.V$Ci/kd.OTzaSGU.TagZ5KjYx2MLzQv2IkZ24E1.yeTT3Pp4o/yniTjus/rRaJ92Z18MVy6suf1W5uxxurqssel.:17465:0:99999:7::: 账号名称： 需要和 /etc/passwd 一致。 密码： 经过加密，虽然加密，但不表示不会被破解，该文件默认权限如下： -rw——- 1 root root 1560 Oct 26 17:20 passwd- 只有root能都读写 最近修改密码日期： 从1970-1-1起，到用户最后一次更改口令的天数 密码最小时间间隔： 从1970-1-1起，到用户可以更改口令的天数 密码最大时间间隔： 从1970-1-1起，必须更改的口令天数 密码到期警告时间： 在口令过期之前几天通知 密码到期后账号宽限时间 密码到期禁用账户时间： 在用户口令过期后到禁用账户的天数 保留 /etc/group用户组的配置文件 1root:x:0: 用户组名称 用户组密码： 给用户组管理员使用，通常不用 GID： 用户组的ID 此用户支持的账号名称： 一个账号可以加入多个用户组，例如想要 itcast 加入 root 这个用户组，将该账号填入该字段即可 root:x:0:root, icast 将用户进行分组是 Linux 对用户进行管理及控制访问权限的一种手段。一个中可以有多个用户，一个用户可以同时属于多个组。该文件对所有用户可读。 /etc/gshadow该文件用户定义用户组口令，组管理员等信息只有root用户可读。 1root:\*:: 用户组名 密码列 用户组管理员的账号 用户组所属账号 账户管理常用命令增加用户123456useradd 用户名useradd -u (UID号)useradd -p (口令)useradd -g (分组)useradd -s (SHELL)useradd -d (用户目录) 如：useradd mirrorming 增加用户名为 mirrorming 的账户 修改用户12345678usermod -u (新UID)usermod -d (用户目录)usermod -g (组名)usermod -s (SHELL)usermod -p (新口令)usermod -l (新登录名)usermod -L (锁定用户账号密码)usermod -U (解锁用户账号) 如：usermod -u 1024 -g group2 -G root mirrorming 将 mirrorming 用户 uid 修改为 1024，默认组改为系统中已经存在的 group2，并且加入到系统管理员组 删除用户12userdel 用户名 (删除用户账号)userdel -r 删除账号时同时删除目录 如：userdel -r mirrorming 删除用户名为 mirrorming 的账户并同时删除 mirrorming 的用户目录 组账户维护12345groupadd 组账户名 (创建新组)groupadd -g 指定组GIDgroupmod -g 更改组的GIDgroupmod -n 更改组账户名groupdel 组账户名 (删除指定组账户) 口令维护1234567passwd 用户账户名 (设置用户口令)passwd -l 用户账户名 (锁定用户账户)passwd -u 用户账户名 (解锁用户账户)passwd -d 用户账户名 (删除账户口令)gpasswd -a 用户账户名 组账户名 (将指定用户添加到指定组)gpasswd -d 用户账户名 组账户名 (将用户从指定组中删除)gpasswd -A 用户账户名 组账户名 (将用户指定为组的管理员) 用户和组状态1234su 用户名(切换用户账户)id 用户名(显示用户的UID，GID)whoami (显示当前用户名称)groups (显示用户所属组) Linux 文件权限管理查看文件和目录的权限ls –al使用 ls 不带参数只显示文件名称，通过ls –al` 可以显示文件或者目录的权限信息。 ls -l 文件名 显示信息包括：文件类型 (d 目录，- 普通文件，l 链接文件)，文件权限，文件的用户，文件的所属组，文件的大小，文件的创建时间，文件的名称 1-rw-r--r-- 1 mirrorming mirrorming 675 Oct 26 17:20 .profile -：普通文件 rw-：说明用户 mirrorming 有读写权限，没有运行权限 r--：表示用户组 mirrorming 只有读权限，没有写和运行的权限 r--：其他用户只有读权限，没有写权限和运行的权限 -rw-r–r– 1 mirrorming mirrorming 675 Oct 26 17:20 .profile 文档类型及权限 连接数 文档所属用户 文档所属组 文档大小 文档最后被修改日期 文档名称 - rw- r– r– 文档类型 文档所有者权限（user） 文档所属用户组权限（group） 其他用户权限（other） 文档类型 d 表示目录 l 表示软连接 – 表示文件 c 表示串行端口字符设备文件 b 表示可供存储的块设备文件 余下的字符 3 个字符为一组。r 只读，w 可写，x 可执行，- 表示无此权限 连接数指有多少个文件指向同一个索引节点。 文档所属用户和所属组就是文档属于哪个用户和用户组。文件所属用户和组是可以更改的 文档大小默认是 bytes 更改操作权限chown是 change owner 的意思，主要作用就是改变文件或者目录所有者，所有者包含用户和用户组 12chown [-R] 用户名称 文件或者目录chown [-R] 用户名称 用户组名称 文件或目录 -R：进行递归式的权限更改，将目录下的所有文件、子目录更新为指定用户组权限 chmod改变访问权限 1chmod [who] [+ | - | =] [mode] 文件名 who表示操作对象可以是以下字母的一个或者组合 u：用户 user g：用户组 group o：表示其他用户 a：表示所有用户是系统默认的 操作符号 +：表示添加某个权限 -：表示取消某个权限 =：赋予给定的权限，取消文档以前的所有权限 mode表示可执行的权限，可以是 r、w、x 文件名文件名可以使空格分开的文件列表 示例123456mirrorming@UbuntuBase:~$ ls -al test.txt -rw-rw-r-- 1 mirrorming mirrorming 6 Nov 2 21:47 test.txtmirrorming@UbuntuBase:~$ chmod u=rwx,g+r,o+r test.txt mirrorming@UbuntuBase:~$ ls -al test.txt -rwxrw-r-- 1 mirrorming mirrorming 6 Nov 2 21:47 test.txtmirrorming@UbuntuBase:~$ 数字设定法数字设定法中数字表示的含义 0 表示没有任何权限 1 表示有可执行权限 = x 2 表示有可写权限 = w 4 表示有可读权限 = r 也可以用数字来表示权限如 chmod 755 file_name r w x r – x r - x 4 2 1 4 - 1 4 - 1 user group others 若要 rwx 属性则 4+2+1=7 若要 rw- 属性则 4+2=6 若要 r-x 属性则 4+1=5 1234567mirrorming@UbuntuBase:~$ chmod 777 test.txt mirrorming@UbuntuBase:~$ ls -al test.txt -rwxrwxrwx 1 mirrorming mirrorming 6 Nov 2 21:47 test.txtmirrorming@UbuntuBase:~$ chmod 770 test.txt mirrorming@UbuntuBase:~$ ls -al test.txt -rwxrwx--- 1 mirrorming mirrorming 6 Nov 2 21:47 test.txt Linux 安装 JavaLinux 安装 Java此处以 JDK 1.8.0_152 为例 下载地址http://www.oracle.com/technetwork/java/javase/downloads/index.html 解压缩并移动到指定目录解压缩1tar -zxvf jdk-8u152-linux-x64.tar.gz 创建目录1mkdir -p /usr/local/java 移动安装包1mv jdk1.8.0_152/ /usr/local/java/ 设置所有者1chown -R root:root /usr/local/java/ 配置环境变量配置系统环境变量1nano /etc/environment 添加如下语句1234PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games&quot;export JAVA_HOME=/usr/local/java/jdk1.8.0_152export JRE_HOME=/usr/local/java/jdk1.8.0_152/jreexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib 配置用户环境变量1nano /etc/profile 添加如下语句1234567891011121314151617181920212223242526272829if [ &quot;$PS1&quot; ]; then if [ &quot;$BASH&quot; ] &amp;&amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then # The file bash.bashrc already sets the default PS1. # PS1=&apos;\h:\w\$ &apos; if [ -f /etc/bash.bashrc ]; then . /etc/bash.bashrc fi else if [ &quot;`id -u`&quot; -eq 0 ]; then PS1=&apos;# &apos; else PS1=&apos;$ &apos; fi fifiexport JAVA_HOME=/usr/local/java/jdk1.8.0_152export JRE_HOME=/usr/local/java/jdk1.8.0_152/jreexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/libexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH:$HOME/binif [ -d /etc/profile.d ]; then for i in /etc/profile.d/*.sh; do if [ -r $i ]; then . $i fi done unset ifi 使用户环境变量生效1source /etc/profile 测试是否安装成功1234root@UbuntuBase:/usr/local/java# java -versionjava version &quot;1.8.0_152&quot;Java(TM) SE Runtime Environment (build 1.8.0_152-b16)Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode) 为其他用户更新用户环境变量12su mirrormingsource /etc/profile Linux 安装 Tomcat此处以 Tomcat 8.5.23 为例 下载地址https://tomcat.apache.org/ 解压缩并移动到指定目录解压缩1tar -zxvf apache-tomcat-8.5.23.tar.gz 变更目录名1mv apache-tomcat-8.5.23 tomcat 移动目录1mv tomcat/ /usr/local/ 常用命令启动1/usr/local/tomcat/bin/startup.sh 停止1/usr/local/tomcat/bin/shutdown.sh 目录内执行脚本1./startup.sh Linux 安装 MySQL安装更新数据源1apt-get update 安装 MySQL1apt-get install mysql-server 系统将提示您在安装过程中创建 root 密码。选择一个安全的密码，并确保你记住它，因为你以后需要它。接下来，我们将完成 MySQL 的配置。 配置因为是全新安装，您需要运行附带的安全脚本。这会更改一些不太安全的默认选项，例如远程 root 登录和示例用户。在旧版本的 MySQL 上，您需要手动初始化数据目录，但 Mysql 5.7 已经自动完成了。 运行安全脚本： 1mysql_secure_installation 这将提示您输入您在之前步骤中创建的 root 密码。您可以按 Y，然后 ENTER 接受所有后续问题的默认值，但是要询问您是否要更改 root 密码。您只需在之前步骤中进行设置即可，因此无需现在更改。 测试按上边方式安装完成后，MySQL 应该已经开始自动运行了。要测试它，请检查其状态。 12345678910lusifer@ubuntu:~$ systemctl status mysql.service● mysql.service - MySQL Community Server Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled) Active: active (running) since Tue 2017-11-21 13:04:34 CST; 3min 24s ago Main PID: 2169 (mysqld) CGroup: /system.slice/mysql.service └─2169 /usr/sbin/mysqldNov 21 13:04:33 ubuntu systemd[1]: Starting MySQL Community Server...Nov 21 13:04:34 ubuntu systemd[1]: Started MySQL Community Server. 查看 MySQL 版本： 1mysqladmin -p -u root version 配置远程访问 修改配置文件 1nano /etc/mysql/mysql.conf.d/mysqld.cnf 注释掉(语句前面加上 # 即可)： 1bind-address = 127.0.0.1 重启 MySQL 1service mysql restart 登录 MySQL 1mysql -u root -p 授权 root 用户允许所有人连接 1grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;你的 mysql root 账户密码&apos;; 因弱口令无法成功授权解决步骤 查看和设置密码安全级别 12select @@validate_password_policy;set global validate_password_policy=0; 查看和设置密码长度限制 12select @@validate_password_length;set global validate_password_length=1; 常用命令启动1service mysql start 停止1service mysql stop 重启1service mysql restart 其它配置修改配置 mysqld.cnf 配置文件 1vi /etc/mysql/mysql.conf.d/mysqld.cnf 配置默认字符集在 [mysqld] 节点上增加如下配置 12[client]default-character-set=utf8 在 [mysqld] 节点底部增加如下配置 123default-storage-engine=INNODBcharacter-set-server=utf8collation-server=utf8_general_ci 配置忽略数据库大小写敏感在 [mysqld] 节点底部增加如下配置 1lower-case-table-names = 1 Linux LVM 磁盘扩容李卫民 发表于 2018-10-31 LVM 的基本概念物理卷 Physical volume (PV)可以在上面建立卷组的媒介，可以是硬盘分区，也可以是硬盘本身或者回环文件（loopback file）。物理卷包括一个特殊的 header，其余部分被切割为一块块物理区域（physical extents）。 卷组 Volume group (VG)将一组物理卷收集为一个管理单元。 逻辑卷 Logical volume (LV)虚拟分区，由物理区域（physical extents）组成。 物理区域 Physical extent (PE)硬盘可供指派给逻辑卷的最小单位（通常为 4MB）。 磁盘操作相关命令df -h（查看挂载点）lvdisplay（显示当前的 logical volume）备注： 注意这里目前有两个，一个是文件系统所在的 volume，另一个是 swap 分区使用的 volume，当然，我们需要扩容的是第一个 vgdisplay（显示当前的 volume group）备注： 注意 VG SIZE，这里应该是你当前的可用空间大小，待扩容完毕，这里显示的应该是最终的大小 pvdisplay（显示当前的 physical volume）开始 LVM 扩容查看 fdisk1fdisk -l 因为这台机器默认开启了 LVM，所以目前有一个 extended 分区和一个 LVM 分区，并且他们是完全重叠的。这是因为，LVM 分区作为一个虚拟的分区，完全占用了这个 extended 分区，因此，现在需要做的就是将 extended partition (sda2) 扩展到最大，然后创建一个新的 LVM logical partition (sda6)，用它来填满 sda2 查看所有连接到电脑上的储存设备1fdisk -l |grep &apos;/dev&apos; 创建 sdb 分区123fdisk /dev/sdbn # 新建分区l # 选择逻辑分区，如果没有，则首先创建扩展分区（p），然后再添加逻辑分区（硬盘：最多四个分区 P-P-P-P 或 P-P-P-E） 1234回车回车回车w # 写入磁盘分区 格式化磁盘1mkfs -t ext4 /dev/sdb1 创建 PV1pvcreate /dev/sdb1 查看卷组1pvscan 扩容 VG1vgdisplay 1vgextend ubuntu-vg /dev/sdb1 扩容 LV1lvextend -L +30G /dev/ubuntu-vg/root 刷新分区1resize2fs /dev/ubuntu-vg/root 删除 unknown device12pvscanvgreduce --removemissing ubuntu-vg 注意：不要卸载扩容的磁盘，可能出现丢失数据或是系统无法启动]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Fastdfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写MyBatis]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%89%8B%E5%86%99Mybatis%2F</url>
    <content type="text"><![CDATA[##手写mybatis注解版实现 ###pom文件12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.mirror&lt;/groupId&gt; &lt;artifactId&gt;mirrorming_mybatisdemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;mirrorming_mybatisdemo&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; ###项目结构 ###MyBatis层次结构 ###新建注解 1234567891011121314151617181920package cn.mirror.mirrorming_mybatisdemo.framework.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 自定义插入注解 * * @author mirror */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface MirrorInsert &#123; String value();&#125; ###UserMapper 12345678910111213141516171819202122232425package cn.mirror.mirrorming_mybatisdemo.mapper;import cn.mirror.mirrorming_mybatisdemo.entity.User;import cn.mirror.mirrorming_mybatisdemo.framework.annotation.MirrorDelete;import cn.mirror.mirrorming_mybatisdemo.framework.annotation.MirrorInsert;import cn.mirror.mirrorming_mybatisdemo.framework.annotation.MirrorParam;import cn.mirror.mirrorming_mybatisdemo.framework.annotation.MirrorSelect;import cn.mirror.mirrorming_mybatisdemo.framework.annotation.MirrorUpdate;/** * @author mirror */public interface UserMapper &#123; @MirrorInsert("insert into user(name,age) values(#&#123;name&#125;,#&#123;age&#125;)") public int insertUser(@MirrorParam("name") String name, @MirrorParam("age") Integer age); @MirrorSelect("select * from User where id=#&#123;id&#125;") User selectUser(@MirrorParam("id") int id); @MirrorDelete("delete from user where id=#&#123;id&#125;") public int deleteUser(@MirrorParam("id") int id); @MirrorUpdate("update user set name =#&#123;name&#125;, age =#&#123;age&#125; where id =#&#123;id&#125;") public int updateUser(@MirrorParam("name") String name, @MirrorParam("age") Integer age, @MirrorParam("id") int id);&#125; ###JDBC工具类12345678910111213141516171819202122232425262728293031323334353637383940414243/** * JDBC 工具类 * @author mirror */public class JDBCUtil &#123; private static String connect; private static String driverClassName; // 驱动名 private static String URL; private static String username; private static String password; private static boolean autoCommit; /* 声明一个Connection类型的静态属性,用来缓存一个已经存在的连接对象 */ private static Connection connection; static &#123; config(); &#125; private static void config() &#123; /* * 获取驱动 */ driverClassName = "com.mysql.jdbc.Driver"; /* * 获取URL */ URL = "jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8"; /* * 获取用户名 */ username = "root"; /* * 获取密码 */ password = "1234"; /* * 设置是否自动提交，一般为false不用改 */ autoCommit = false; &#125; ... ###SQL转换工具类将#{xxx}转换为?123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114public class SQLUtil &#123; // 测试用 public static void main(String[] args) &#123; String sql = "select * from User where name=#&#123;name&#125; and age=#&#123;age&#125;"; List&lt;String&gt; sqlParameter = sqlSelectParameter(sql); for (String string : sqlParameter) &#123; System.out.println(string); &#125; &#125; /** * 获取Insert语句后面values 参数信息&lt;br&gt; * sql:insert into user(name,age) values(#&#123;name&#125;,#&#123;age&#125;) * * @param sql * @return */ public static String[] sqlInsertParameter(String sql) &#123; int startIndex = sql.indexOf("values");// 从values开始找 int endIndex = sql.length();// 到sql末尾 String sqlSubString = sql.substring(startIndex + 6, endIndex).replace("(", "").replace(")", "") .replace("#&#123;", "").replace("&#125;", "");// 从values后面开始找替换掉括号 System.out.println(sqlSubString);// 变成name,age String[] split = sqlSubString.split(",");// 将name,age转为数组&#123;name,age&#125; return split; &#125; /** * 使用正则表达式获取Update语句后面 参数信息&lt;br&gt; * sql:update user set name =#&#123;name&#125;, age =#&#123;age&#125; where id =#&#123;id&#125; * * @param sql * @return List */ public static List&lt;String&gt; sqlUpdateParameter(String sql) &#123; Pattern pattern = Pattern.compile("\\&#123;+\\w+\\&#125;"); Matcher matcher = pattern.matcher(sql); List&lt;String&gt; list = new ArrayList&lt;&gt;(); while (matcher.find()) &#123; String temp = matcher.group(); String param = temp.substring(1, temp.length() - 1); list.add(param); &#125; System.out.println(list); return list; &#125; /** * 获取Delete语句后面 参数信息&lt;br&gt; * sql:delete from user where id=#&#123;id&#125; * * @param sql * @return */ public static String sqlDeleteParameter(String sql) &#123; int startIndex = sql.indexOf("id");// 从values开始找 int endIndex = sql.length();// 到sql末尾 String sqlSubString = sql.substring(startIndex + 2, endIndex).replace("=#&#123;", "").replace("&#125;", "");// 从values后面开始找替换掉括号 System.out.println(sqlSubString);// 变成name,age return sqlSubString; &#125; /** * 使用正则表达式获取Select语句后面 参数信息&lt;br&gt; * sql:select * from User where name=#&#123;name&#125; and age=#&#123;name&#125; * * @param sql * @return List */ public static List&lt;String&gt; sqlSelectParameter(String sql) &#123; Pattern pattern = Pattern.compile("\\&#123;+\\w+\\&#125;"); Matcher matcher = pattern.matcher(sql); List&lt;String&gt; list = new ArrayList&lt;&gt;(); while (matcher.find()) &#123; String temp = matcher.group(); String param = temp.substring(1, temp.length() - 1); list.add(param); &#125; System.out.println(list); return list; &#125; /** * 将SQL语句的参数替换变为? * * @param sql * @param parameterName * @return */ public static String parameQuestion(String sql, String[] parameterName) &#123; for (int i = 0; i &lt; parameterName.length; i++) &#123; String str = parameterName[i]; sql = sql.replace("#&#123;" + str + "&#125;", "?"); &#125; return sql; &#125; public static String parameQuestion(String sql, String parameterName) &#123; String str = parameterName; sql = sql.replace("#&#123;" + str + "&#125;", "?"); return sql; &#125; public static String parameQuestion(String sql, List&lt;String&gt; parameterName) &#123; for (int i = 0; i &lt; parameterName.size(); i++) &#123; String str = parameterName.get(i); sql = sql.replace("#&#123;" + str + "&#125;", "?"); &#125; return sql; &#125;&#125; ###实体类123456public class User &#123; private int id; private String name; private int age; 省略Get ,Set和toString&#125; ###动态代理实现接口映射 ###SqlSession类123456789101112131415161718package cn.mirror.mirrorming_mybatisdemo.framework.sql;import java.lang.reflect.Proxy;import cn.mirror.mirrorming_mybatisdemo.framework.aop.MyBatisInvocationHandler;/** * @author mirror */public class SqlSession &#123; // 加载Mapper接口 @SuppressWarnings("unchecked") public static &lt;T&gt; T getMapper(Class clazz) &#123; return (T) Proxy.newProxyInstance(clazz.getClassLoader(), new Class[] &#123; clazz &#125;, new MyBatisInvocationHandler(clazz)); &#125;&#125; ###MyBatisInvocationHandler类–核心类主要业务逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206package cn.mirror.mirrorming_mybatisdemo.framework.aop;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Parameter;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import java.util.concurrent.ConcurrentHashMap;import cn.mirror.mirrorming_mybatisdemo.entity.User;import cn.mirror.mirrorming_mybatisdemo.framework.annotation.MirrorDelete;import cn.mirror.mirrorming_mybatisdemo.framework.annotation.MirrorInsert;import cn.mirror.mirrorming_mybatisdemo.framework.annotation.MirrorParam;import cn.mirror.mirrorming_mybatisdemo.framework.annotation.MirrorSelect;import cn.mirror.mirrorming_mybatisdemo.framework.annotation.MirrorUpdate;import cn.mirror.mirrorming_mybatisdemo.framework.utils.JDBCUtil;import cn.mirror.mirrorming_mybatisdemo.framework.utils.SQLUtil;/** * @author mirror */public class MyBatisInvocationHandler implements InvocationHandler &#123; private Object object; public MyBatisInvocationHandler(Object object) &#123; this.object = object; &#125; // proxy 代理对象,method拦截方法 ,args方法上的参数值 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("使用动态代理拦截接口开始"); // 1. 判断方法上是否存在@MirrorInsert MirrorInsert mirrorInsert = method.getDeclaredAnnotation(MirrorInsert.class); if (mirrorInsert != null) &#123; return mirrorInsert(mirrorInsert, proxy, method, args); &#125; // 2. 判断方法上是否存在@MirrorDelete MirrorDelete mirrorDelete = method.getDeclaredAnnotation(MirrorDelete.class); if (mirrorDelete != null) &#123; return mirrorDelete(mirrorDelete, proxy, method, args); &#125; // 3. 判断方法上是否存在@MirrorDelete MirrorUpdate mirrorUpdate = method.getDeclaredAnnotation(MirrorUpdate.class); if (mirrorUpdate != null) &#123; return mirrorUpdate(mirrorUpdate, proxy, method, args); &#125; // 4. 判断方法上是否存在@MirrorSelect MirrorSelect mirrorSelect = method.getDeclaredAnnotation(MirrorSelect.class); if (mirrorSelect != null) &#123; return mirrorSelect(mirrorSelect, proxy, method, args); &#125; return null; &#125; // 查 private Object mirrorSelect(MirrorSelect mirrorSelect, Object proxy, Method method, Object[] args) throws SQLException, InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException, IllegalArgumentException, InvocationTargetException &#123; // 1.查询的思路 // 2. 获取注解上查询的SQL语句 String selectSQL = mirrorSelect.value(); // 3. 获取方法上的参数,绑定在一起 ConcurrentHashMap&lt;Object, Object&gt; paramsMap = paramsMap(proxy, method, args); // 4. 参数替换？传递方式 List&lt;String&gt; sqlSelectParameter = SQLUtil.sqlSelectParameter(selectSQL); // 5.传递参数 List&lt;Object&gt; sqlParams = new ArrayList&lt;&gt;(); for (String parameterName : sqlSelectParameter) &#123; Object parameterValue = paramsMap.get(parameterName); sqlParams.add(parameterValue); &#125; // 6.将sql语句替换成? String newSql = SQLUtil.parameQuestion(selectSQL, sqlSelectParameter); System.out.println("newSQL:" + newSql + ",sqlParams:" + sqlParams.toString()); // 5.调用jdbc代码底层执行sql语句 // 6.使用反射机制实例对象### 获取方法返回的类型，进行实例化 // 思路: // 1.使用反射机制获取方法的类型 // 2.判断是否有结果集,如果有结果集，在进行初始化 // 3.使用反射机制,给对象赋值 ResultSet res = JDBCUtil.query(newSql, sqlParams); while (res.next()) &#123; // 使用反射机制获取方法的类型 Class&lt;?&gt; returnType = method.getReturnType(); Object object = returnType.newInstance(); // 获取当前所有的属性 // 注:Field.getGenericType()：如果当前属性有签名属性类型就返回，否则就返回 Field.getType() Field[] declaredFields = returnType.getDeclaredFields(); for (Field field : declaredFields) &#123; String fieldName = field.getName(); Object fieldValue = res.getObject(fieldName); field.setAccessible(true); field.set(object, fieldValue); &#125; return object; &#125; return null; &#125; // 改 private Object mirrorUpdate(MirrorUpdate mirrorUpdate, Object proxy, Method method, Object[] args) &#123; // 方法上存在@mirrorUpdate,获取他的SQL语句 // 2. 获取SQL语句,获取注解mirrorUpdate语句 String updateSql = mirrorUpdate.value(); System.out.println("updateSql:" + updateSql); // 3. 获取方法的参数和SQL参数进行匹配 // 定一个一个Map集合 KEY为@MirrorParamValue,Value 结果为参数值 ConcurrentHashMap&lt;Object, Object&gt; paramsMap = paramsMap(proxy, method, args); // 存放sql执行的参数---参数绑定过程 List sqlInsertParameter = SQLUtil.sqlUpdateParameter(updateSql); List&lt;Object&gt; sqlParams = sqlParams(sqlInsertParameter, paramsMap); // 4. 根据参数替换参数变为? String newSQL = SQLUtil.parameQuestion(updateSql, sqlInsertParameter); System.out.println("newSQL:" + newSQL + ",sqlParams:" + sqlParams.toString()); // 5. 调用jdbc底层代码执行语句 return JDBCUtil.update(newSQL, false, sqlParams); &#125; // 增 private Object mirrorInsert(MirrorInsert mirrorInsert, Object proxy, Method method, Object[] args) &#123; // 方法上存在@MirrorInsert,获取他的SQL语句 // 2. 获取SQL语句,获取注解Insert语句 String insertSql = mirrorInsert.value(); // System.out.println("insertSql:" + insertSql); // 3. 获取方法的参数和SQL参数进行匹配 // 定一个一个Map集合 KEY为@MirrorParamValue,Value 结果为参数值 ConcurrentHashMap&lt;Object, Object&gt; paramsMap = paramsMap(proxy, method, args); // 存放sql执行的参数---参数绑定过程 String[] sqlInsertParameter = SQLUtil.sqlInsertParameter(insertSql); List&lt;Object&gt; sqlParams = sqlParams(sqlInsertParameter, paramsMap); // 4. 根据参数替换参数变为? String newSQL = SQLUtil.parameQuestion(insertSql, sqlInsertParameter); System.out.println("newSQL:" + newSQL + ",sqlParams:" + sqlParams.toString()); // 5. 调用jdbc底层代码执行语句 return JDBCUtil.insert(newSQL, false, sqlParams); &#125; // 删 private Object mirrorDelete(MirrorDelete mirrorDelete, Object proxy, Method method, Object[] args) &#123; // 方法上存在@MirrorDelete,获取他的SQL语句 // 2. 获取SQL语句,获取注解Delete语句 String deleteSql = mirrorDelete.value(); System.out.println("f(mirrorDelete)------deleteSql:" + deleteSql); // 3. 获取方法的参数和SQL参数进行匹配 // 定一个一个Map集合 KEY为@MirrorParamValue,Value 结果为参数值 ConcurrentHashMap&lt;Object, Object&gt; paramsMap = paramsMap(proxy, method, args); // 存放sql执行的参数---参数绑定过程 String sqlDeleteParameter = SQLUtil.sqlDeleteParameter(deleteSql); String sqlParam = singleSqlParams(sqlDeleteParameter, paramsMap); // 4. 根据参数替换参数变为? String newSQL = SQLUtil.parameQuestion(deleteSql, sqlDeleteParameter); System.out.println("newSQL:" + newSQL + ",sqlParams:" + sqlParam.toString()); // 5. 调用jdbc底层代码执行语句 return JDBCUtil.delete(newSQL, false, sqlParam); &#125; private List&lt;Object&gt; sqlParams(String[] sqlInsertParameter, ConcurrentHashMap&lt;Object, Object&gt; paramsMap) &#123; List&lt;Object&gt; sqlParams = new ArrayList&lt;&gt;(); for (String paramName : sqlInsertParameter) &#123; Object paramValue = paramsMap.get(paramName); sqlParams.add(paramValue); &#125; return sqlParams; &#125; private List&lt;Object&gt; sqlParams(List&lt;String&gt; sqlInsertParameter, ConcurrentHashMap&lt;Object, Object&gt; paramsMap) &#123; List&lt;Object&gt; sqlParams = new ArrayList&lt;&gt;(); for (String paramName : sqlInsertParameter) &#123; Object paramValue = paramsMap.get(paramName); sqlParams.add(paramValue); &#125; return sqlParams; &#125; private String singleSqlParams(String sqlDeleteParameter, ConcurrentHashMap&lt;Object, Object&gt; paramsMap) &#123; return paramsMap.get(sqlDeleteParameter).toString(); &#125; // 将方法注解上的参数和定义的局部变量绑定并且放置到map中 private ConcurrentHashMap&lt;Object, Object&gt; paramsMap(Object proxy, Method method, Object[] args) &#123; ConcurrentHashMap&lt;Object, Object&gt; paramsMap = new ConcurrentHashMap&lt;&gt;(); // 获取方法上的参数 Parameter[] parameters = method.getParameters(); for (int i = 0; i &lt; parameters.length; i++) &#123; Parameter parameter = parameters[i]; MirrorParam mirrorParam = parameter.getDeclaredAnnotation(MirrorParam.class); if (mirrorParam != null) &#123; // 参数名称 String paramName = mirrorParam.value(); Object paramValue = args[i]; // System.out.println(paramName + "," + paramValue); paramsMap.put(paramName, paramValue); &#125; &#125; return paramsMap; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用工具类]]></title>
    <url>%2F2018%2F06%2F19%2FToolsClass%2F</url>
    <content type="text"><![CDATA[CookieUtils123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.net.URLEncoder;/** * Cookie 工具类 */public final class CookieUtils &#123; /** * 得到Cookie的值, 不编码 * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName) &#123; return getCookieValue(request, cookieName, false); &#125; /** * 得到Cookie的值, * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName, boolean isDecoder) &#123; Cookie[] cookieList = request.getCookies(); if (cookieList == null || cookieName == null) &#123; return null; &#125; String retValue = null; try &#123; for (int i = 0; i &lt; cookieList.length; i++) &#123; if (cookieList[i].getName().equals(cookieName)) &#123; if (isDecoder) &#123; retValue = URLDecoder.decode(cookieList[i].getValue(), "UTF-8"); &#125; else &#123; retValue = cookieList[i].getValue(); &#125; break; &#125; &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return retValue; &#125; /** * 得到Cookie的值, * * @param request * @param cookieName * @return */ public static String getCookieValue(HttpServletRequest request, String cookieName, String encodeString) &#123; Cookie[] cookieList = request.getCookies(); if (cookieList == null || cookieName == null) &#123; return null; &#125; String retValue = null; try &#123; for (int i = 0; i &lt; cookieList.length; i++) &#123; if (cookieList[i].getName().equals(cookieName)) &#123; retValue = URLDecoder.decode(cookieList[i].getValue(), encodeString); break; &#125; &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return retValue; &#125; /** * 设置Cookie的值 不设置生效时间默认浏览器关闭即失效,也不编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue) &#123; setCookie(request, response, cookieName, cookieValue, -1); &#125; /** * 设置Cookie的值 在指定时间内生效,但不编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage) &#123; setCookie(request, response, cookieName, cookieValue, cookieMaxage, false); &#125; /** * 设置Cookie的值 不设置生效时间,但编码 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, boolean isEncode) &#123; setCookie(request, response, cookieName, cookieValue, -1, isEncode); &#125; /** * 设置Cookie的值 在指定时间内生效, 编码参数 */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) &#123; doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, isEncode); &#125; /** * 设置Cookie的值 在指定时间内生效, 编码参数(指定编码) */ public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, String encodeString) &#123; doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, encodeString); &#125; /** * 删除Cookie带cookie域名 */ public static void deleteCookie(HttpServletRequest request, HttpServletResponse response, String cookieName) &#123; doSetCookie(request, response, cookieName, "", -1, false); &#125; /** * 设置Cookie的值，并使其在指定时间内生效 * * @param cookieMaxage cookie生效的最大秒数 */ private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) &#123; try &#123; if (cookieValue == null) &#123; cookieValue = ""; &#125; else if (isEncode) &#123; cookieValue = URLEncoder.encode(cookieValue, "utf-8"); &#125; Cookie cookie = new Cookie(cookieName, cookieValue); if (cookieMaxage &gt; 0) cookie.setMaxAge(cookieMaxage); if (null != request) &#123;// 设置域名的cookie String domainName = getDomainName(request);// System.out.println(domainName); if (!"localhost".equals(domainName)) &#123; cookie.setDomain(domainName); &#125; &#125; cookie.setPath("/"); response.addCookie(cookie); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 设置Cookie的值，并使其在指定时间内生效 * * @param cookieMaxage cookie生效的最大秒数 */ private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response, String cookieName, String cookieValue, int cookieMaxage, String encodeString) &#123; try &#123; if (cookieValue == null) &#123; cookieValue = ""; &#125; else &#123; cookieValue = URLEncoder.encode(cookieValue, encodeString); &#125; Cookie cookie = new Cookie(cookieName, cookieValue); if (cookieMaxage &gt; 0) cookie.setMaxAge(cookieMaxage); if (null != request) &#123;// 设置域名的cookie String domainName = getDomainName(request);// System.out.println(domainName); if (!"localhost".equals(domainName)) &#123; cookie.setDomain(domainName); &#125; &#125; cookie.setPath("/"); response.addCookie(cookie); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 得到cookie的域名 */ private static final String getDomainName(HttpServletRequest request) &#123; String domainName = null; String serverName = request.getRequestURL().toString(); if (serverName == null || serverName.equals("")) &#123; domainName = ""; &#125; else &#123; serverName = serverName.toLowerCase(); serverName = serverName.substring(7); final int end = serverName.indexOf("/"); serverName = serverName.substring(0, end); final String[] domains = serverName.split("\\."); int len = domains.length; if (len &gt; 3) &#123; // www.xxx.cn domainName = "." + domains[len - 3] + "." + domains[len - 2] + "." + domains[len - 1]; &#125; else if (len &lt;= 3 &amp;&amp; len &gt; 1) &#123; // xxx.com or xxx.cn domainName = "." + domains[len - 2] + "." + domains[len - 1]; &#125; else &#123; domainName = serverName; &#125; &#125; if (domainName != null &amp;&amp; domainName.indexOf(":") &gt; 0) &#123; String[] ary = domainName.split("\\:"); domainName = ary[0]; &#125; return domainName; &#125;&#125; RegexpUtils正则表达式工具类1234567891011121314151617181920212223242526272829303132/** * 正则表达式工具类 */public class RegexpUtils &#123; /** * 验证手机号 */ public static final String PHONE = "^((13[0-9])|(15[^4,\\D])|(18[0,5-9]))\\d&#123;8&#125;$"; /** * 验证邮箱地址 */ public static final String EMAIL = "\\w+(\\.\\w)*@\\w+(\\.\\w&#123;2,3&#125;)&#123;1,3&#125;"; /** * 验证手机号 * @param phone * @return */ public static boolean checkPhone(String phone) &#123; return phone.matches(PHONE); &#125; /** * 验证邮箱 * @param email * @return */ public static boolean checkEmail(String email) &#123; return email.matches(EMAIL); &#125;&#125; Jackson 工具类MapperUtils123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220import com.fasterxml.jackson.annotation.JsonInclude;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.ObjectMapper;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Jackson 工具类 */public class MapperUtils &#123; private final static ObjectMapper objectMapper = new ObjectMapper(); public static ObjectMapper getInstance() &#123; return objectMapper; &#125; /** * 转换为 JSON 字符串 * * @param obj * @return * @throws Exception */ public static String obj2json(Object obj) throws Exception &#123; return objectMapper.writeValueAsString(obj); &#125; /** * 转换为 JSON 字符串，忽略空值 * * @param obj * @return * @throws Exception */ public static String obj2jsonIgnoreNull(Object obj) throws Exception &#123; ObjectMapper mapper = new ObjectMapper(); mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); return mapper.writeValueAsString(obj); &#125; /** * 转换为 JavaBean * * @param jsonString * @param clazz * @return * @throws Exception */ public static &lt;T&gt; T json2pojo(String jsonString, Class&lt;T&gt; clazz) throws Exception &#123; objectMapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true); return objectMapper.readValue(jsonString, clazz); &#125; /** * 字符串转换为 Map&lt;String, Object&gt; * * @param jsonString * @return * @throws Exception */ public static &lt;T&gt; Map&lt;String, Object&gt; json2map(String jsonString) throws Exception &#123; ObjectMapper mapper = new ObjectMapper(); mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); return mapper.readValue(jsonString, Map.class); &#125; /** * 字符串转换为 Map&lt;String, T&gt; */ public static &lt;T&gt; Map&lt;String, T&gt; json2map(String jsonString, Class&lt;T&gt; clazz) throws Exception &#123; Map&lt;String, Map&lt;String, Object&gt;&gt; map = objectMapper.readValue(jsonString, new TypeReference&lt;Map&lt;String, T&gt;&gt;() &#123; &#125;); Map&lt;String, T&gt; result = new HashMap&lt;String, T&gt;(); for (Map.Entry&lt;String, Map&lt;String, Object&gt;&gt; entry : map.entrySet()) &#123; result.put(entry.getKey(), map2pojo(entry.getValue(), clazz)); &#125; return result; &#125; /** * 深度转换 JSON 成 Map * * @param json * @return */ public static Map&lt;String, Object&gt; json2mapDeeply(String json) throws Exception &#123; return json2MapRecursion(json, objectMapper); &#125; /** * 把 JSON 解析成 List，如果 List 内部的元素存在 jsonString，继续解析 * * @param json * @param mapper 解析工具 * @return * @throws Exception */ private static List&lt;Object&gt; json2ListRecursion(String json, ObjectMapper mapper) throws Exception &#123; if (json == null) &#123; return null; &#125; List&lt;Object&gt; list = mapper.readValue(json, List.class); for (Object obj : list) &#123; if (obj != null &amp;&amp; obj instanceof String) &#123; String str = (String) obj; if (str.startsWith("[")) &#123; obj = json2ListRecursion(str, mapper); &#125; else if (obj.toString().startsWith("&#123;")) &#123; obj = json2MapRecursion(str, mapper); &#125; &#125; &#125; return list; &#125; /** * 把 JSON 解析成 Map，如果 Map 内部的 Value 存在 jsonString，继续解析 * * @param json * @param mapper * @return * @throws Exception */ private static Map&lt;String, Object&gt; json2MapRecursion(String json, ObjectMapper mapper) throws Exception &#123; if (json == null) &#123; return null; &#125; Map&lt;String, Object&gt; map = mapper.readValue(json, Map.class); for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123; Object obj = entry.getValue(); if (obj != null &amp;&amp; obj instanceof String) &#123; String str = ((String) obj); if (str.startsWith("[")) &#123; List&lt;?&gt; list = json2ListRecursion(str, mapper); map.put(entry.getKey(), list); &#125; else if (str.startsWith("&#123;")) &#123; Map&lt;String, Object&gt; mapRecursion = json2MapRecursion(str, mapper); map.put(entry.getKey(), mapRecursion); &#125; &#125; &#125; return map; &#125; /** * 将 JSON 数组转换为集合 * * @param jsonArrayStr * @param clazz * @return * @throws Exception */ public static &lt;T&gt; List&lt;T&gt; json2list(String jsonArrayStr, Class&lt;T&gt; clazz) throws Exception &#123; JavaType javaType = getCollectionType(ArrayList.class, clazz); List&lt;T&gt; list = (List&lt;T&gt;) objectMapper.readValue(jsonArrayStr, javaType); return list; &#125; /** * 获取泛型的 Collection Type * * @param collectionClass 泛型的Collection * @param elementClasses 元素类 * @return JavaType Java类型 * @since 1.0 */ public static JavaType getCollectionType(Class&lt;?&gt; collectionClass, Class&lt;?&gt;... elementClasses) &#123; return objectMapper.getTypeFactory().constructParametricType(collectionClass, elementClasses); &#125; /** * 将 Map 转换为 JavaBean * * @param map * @param clazz * @return */ public static &lt;T&gt; T map2pojo(Map map, Class&lt;T&gt; clazz) &#123; return objectMapper.convertValue(map, clazz); &#125; /** * 将 Map 转换为 JSON * * @param map * @return */ public static String mapToJson(Map map) &#123; try &#123; return objectMapper.writeValueAsString(map); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return ""; &#125; /** * 将 JSON 对象转换为 JavaBean * * @param obj * @param clazz * @return */ public static &lt;T&gt; T obj2pojo(Object obj, Class&lt;T&gt; clazz) &#123; return objectMapper.convertValue(obj, clazz); &#125;&#125; 日期工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298/** * 日期时间工具类 * @type &#123;&#123;dateFormat&#125;&#125; */var DateTime = function () &#123; var patterns = &#123; PATTERN_ERA: 'G', // Era 标志符 Era strings. For example: "AD" and "BC" PATTERN_YEAR: 'y', // 年 PATTERN_MONTH: 'M', // 月份 PATTERN_DAY_OF_MONTH: 'd', // 月份的天数 PATTERN_HOUR_OF_DAY1: 'k', // 一天中的小时数（1-24） PATTERN_HOUR_OF_DAY0: 'H', // 24 小时制，一天中的小时数（0-23） PATTERN_MINUTE: 'm', // 小时中的分钟数 PATTERN_SECOND: 's', // 秒 PATTERN_MILLISECOND: 'S', // 毫秒 PATTERN_DAY_OF_WEEK: 'E', // 一周中对应的星期，如星期一，周一 PATTERN_DAY_OF_YEAR: 'D', // 一年中的第几天 PATTERN_DAY_OF_WEEK_IN_MONTH: 'F', // 一月中的第几个星期(会把这个月总共过的天数除以7,不够准确，推荐用W) PATTERN_WEEK_OF_YEAR: 'w', // 一年中的第几个星期 PATTERN_WEEK_OF_MONTH: 'W', // 一月中的第几星期(会根据实际情况来算) PATTERN_AM_PM: 'a', // 上下午标识 PATTERN_HOUR1: 'h', // 12 小时制 ，am/pm 中的小时数（1-12） PATTERN_HOUR0: 'K', // 和 h 类型 PATTERN_ZONE_NAME: 'z', // 时区名 PATTERN_ZONE_VALUE: 'Z', // 时区值 PATTERN_WEEK_YEAR: 'Y', // 和 y 类型 PATTERN_ISO_DAY_OF_WEEK: 'u', PATTERN_ISO_ZONE: 'X' &#125;; var week = &#123; 'ch': &#123; "0": "\u65e5", "1": "\u4e00", "2": "\u4e8c", "3": "\u4e09", "4": "\u56db", "5": "\u4e94", "6": "\u516d" &#125;, 'en': &#123; "0": "Sunday", "1": "Monday", "2": "Tuesday", "3": "Wednesday", "4": "Thursday", "5": "Friday", "6": "Saturday" &#125; &#125;; /** * 获取当前时间 * @returns &#123;string&#125; */ var handlerGetCurrentTime = function () &#123; var today = new Date(); var year = today.getFullYear(); var month = today.getMonth() + 1; var day = today.getDate(); var hours = today.getHours(); var minutes = today.getMinutes(); var seconds = today.getSeconds(); var timeString = year + "-" + month + "-" + day + " " + hours + ":" + minutes + ":" + seconds; return timeString; &#125;; /** * 比较时间大小 * time1 &gt; time2 return 1 * time1 &lt; time2 return -1 * time1 == time2 return 0 * @param time1 * @param time2 * @returns &#123;number&#125; */ var handlerCompareTime = function (time1, time2) &#123; if (Date.parse(time1.replace(/-/g, "/")) &gt; Date.parse(time2.replace(/-/g, "/"))) &#123; return 1; &#125; else if (Date.parse(time1.replace(/-/g, "/")) &lt; Date.parse(time2.replace(/-/g, "/"))) &#123; return -1; &#125; else if (Date.parse(time1.replace(/-/g, "/")) == Date.parse(time2.replace(/-/g, "/"))) &#123; return 0; &#125; &#125;; /** * 是否闰年 * @param year * @returns &#123;boolean&#125; */ var handlerIsLeapYear = function (year) &#123; return ((year % 4 === 0 &amp;&amp; year % 100 !== 0) || year % 400 === 0); &#125;; /** * 获取某个月的天数，从 0 开始 * @param year * @param month * @returns &#123;*&#125; */ var handlerGetDaysOfMonth = function (year, month) &#123; return [31, (this.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month]; &#125;; /** * 获取某个月的天数，从 0 开始 * @param year * @param month * @returns &#123;number&#125; */ var handlerGetDaysOfMonth2 = function (year, month) &#123; // 将天置为 0，会获取其上个月的最后一天 month = parseInt(month) + 1; var date = new Date(year, month, 0); return date.getDate(); &#125;; /** * 距离现在几天的日期：负数表示今天之前的日期，0 表示今天，整数表示未来的日期 * 如 -1 表示昨天的日期，0 表示今天，2 表示后天 * @param days * @returns &#123;string&#125; */ var handlerFromToday = function (days) &#123; var today = new Date(); today.setDate(today.getDate() + days); var date = today.getFullYear() + "-" + (today.getMonth() + 1) + "-" + today.getDate(); return date; &#125;; /** * 格式化日期时间 * @param dateTime 需要格式化的日期时间 * @param pattern 格式化的模式，如 yyyy-MM-dd hh(HH):mm:ss.S a k K E D F w W z Z * @returns &#123;*&#125; */ var handlerFormat = function (dateTime, pattern) &#123; var date = new Date(dateTime); if (pattern == null || pattern.length == 0) &#123; return date.toLocaleString(); &#125; return pattern.replace(/([a-z])\1*/ig, function (matchStr, group1) &#123; var replacement = ""; switch (group1) &#123; case patterns.PATTERN_ERA: //G break; case patterns.PATTERN_WEEK_YEAR: //Y case patterns.PATTERN_YEAR: //y replacement = date.getFullYear(); break; case patterns.PATTERN_MONTH: //M var month = date.getMonth() + 1; replacement = (month &lt; 10 &amp;&amp; matchStr.length &gt;= 2) ? "0" + month : month; break; case patterns.PATTERN_DAY_OF_MONTH: //d var days = date.getDate(); replacement = (days &lt; 10 &amp;&amp; matchStr.length &gt;= 2) ? "0" + days : days; break; case patterns.PATTERN_HOUR_OF_DAY1: //k(1~24) var hours24 = date.getHours(); replacement = hours24; break; case patterns.PATTERN_HOUR_OF_DAY0: //H(0~23) var hours24 = date.getHours(); replacement = (hours24 &lt; 10 &amp;&amp; matchStr.length &gt;= 2) ? "0" + hours24 : hours24; break; case patterns.PATTERN_MINUTE: //m var minutes = date.getMinutes(); replacement = (minutes &lt; 10 &amp;&amp; matchStr.length &gt;= 2) ? "0" + minutes : minutes; break; case patterns.PATTERN_SECOND: //s var seconds = date.getSeconds(); replacement = (seconds &lt; 10 &amp;&amp; matchStr.length &gt;= 2) ? "0" + seconds : seconds; break; case patterns.PATTERN_MILLISECOND: //S var milliSeconds = date.getMilliseconds(); replacement = milliSeconds; break; case patterns.PATTERN_DAY_OF_WEEK: //E var day = date.getDay(); replacement = week['ch'][day]; break; case patterns.PATTERN_DAY_OF_YEAR: //D replacement = dayOfTheYear(date); break; case patterns.PATTERN_DAY_OF_WEEK_IN_MONTH: //F var days = date.getDate(); replacement = Math.floor(days / 7); break; case patterns.PATTERN_WEEK_OF_YEAR: //w var days = dayOfTheYear(date); replacement = Math.ceil(days / 7); break; case patterns.PATTERN_WEEK_OF_MONTH: //W var days = date.getDate(); replacement = Math.ceil(days / 7); break; case patterns.PATTERN_AM_PM: //a var hours24 = date.getHours(); replacement = hours24 &lt; 12 ? "\u4e0a\u5348" : "\u4e0b\u5348"; break; case patterns.PATTERN_HOUR1: //h(1~12) var hours12 = date.getHours() % 12 || 12; //0转为12 replacement = (hours12 &lt; 10 &amp;&amp; matchStr.length &gt;= 2) ? "0" + hours12 : hours12; break; case patterns.PATTERN_HOUR0: //K(0~11) var hours12 = date.getHours() % 12; replacement = hours12; break; case patterns.PATTERN_ZONE_NAME: //z replacement = handlerGetZoneNameValue(date)['name']; break; case patterns.PATTERN_ZONE_VALUE: //Z replacement = handlerGetZoneNameValue(date)['value']; break; case patterns.PATTERN_ISO_DAY_OF_WEEK: //u break; case patterns.PATTERN_ISO_ZONE: //X break; default: break; &#125; return replacement; &#125;); &#125;; /** * 计算一个日期是当年的第几天 * @param date * @returns &#123;number&#125; */ var handlerDayOfTheYear = function (date) &#123; var obj = new Date(date); var year = obj.getFullYear(); var month = obj.getMonth(); //从0开始 var days = obj.getDate(); var daysArr = [31, (this.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; for (var i = 0; i &lt; month; i++) &#123; days += daysArr[i]; &#125; return days; &#125;; /** * 获得时区名和值 * @param dateObj * @returns &#123;&#123;name: string, value: string&#125;&#125; */ var handlerGetZoneNameValue = function (dateObj) &#123; var date = new Date(dateObj); date = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate())); var arr = date.toString().match(/([A-Z]+)([-+]\d+:?\d+)/); var obj = &#123; 'name': arr[1], 'value': arr[2] &#125;; return obj; &#125;; return &#123; getCurrentTime: function () &#123; return handlerGetCurrentTime(); &#125;, compareTime: function (time1, time2) &#123; return handlerCompareTime(time1, time2); &#125;, isLeapYear: function (year) &#123; return handlerIsLeapYear(year); &#125;, getDaysOfMonth: function (year, month) &#123; return handlerGetDaysOfMonth(year, month); &#125;, getDaysOfMonth2: function (year, month) &#123; return handlerGetDaysOfMonth2(year, month); &#125;, fromToday: function (days) &#123; return handlerFromToday(days); &#125;, format: function (dateTime, pattern) &#123; return handlerFormat(dateTime, pattern); &#125;, dayOfTheYear: function (date) &#123; return handlerDayOfTheYear(date); &#125;, getZoneNameValue: function (dateObj) &#123; return handlerGetZoneNameValue(dateObj); &#125; &#125;&#125;();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用]]></title>
    <url>%2F2018%2F06%2F12%2FGit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git 的基本操作获取与创建项目命令git init用 git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。 1git init git clone使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。 1git clone [url] 基本快照git addgit add 命令可将该文件添加到缓存 1git add &lt;filename&gt; git statusgit status 以查看在你上次提交之后是否有修改。 12git statusgit status -s git diff执行 git diff 来查看执行 git status 的结果的详细信息。 git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。 尚未缓存的改动：git diff 查看已缓存的改动： git diff –cached 查看已缓存的与未缓存的所有改动：git diff HEAD 显示摘要而非整个 diff：git diff –stat git commit使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。 Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。 12git config --global user.name &apos;yourname&apos;git config --global user.email youremail 将文件写入缓存区并提供提交注释 1git commit -m &apos;update message&apos; git reset HEADgit reset HEAD 命令用于取消已缓存的内容。 1git reset HEAD -- &lt;filename&gt; 拉取与推送git pullgit pull命令用于从另一个存储库或本地分支获取并集成(整合)。git pull命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并，它的完整格式稍稍有点复杂。 1git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 将远程存储库中的更改合并到当前分支中。在默认模式下，git pull是git fetch后跟git merge FETCH_HEAD的缩写。更准确地说，git pull使用给定的参数运行git fetch，并调用git merge将检索到的分支头合并到当前分支中。 git pushgit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相似。 1git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 标签git tag如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 比如说，我们想为我们的 商城 项目发布一个”1.0.0”版本。 我们可以用 git tag -a v1.0.0 命令给最新一次提交打上（HEAD） “v1.0.0” 的标签。 -a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。 1git tag -a v1.0.0 如果我们要查看所有标签可以使用以下命令： 1git tag TortoiseGit 简化 Git 操作李卫民 发表于 2018-05-22 TortoiseGit, 中文名海龟 Git. 海龟 Git 只支持 Windows 系统, 有一个前辈海龟 SVN, TortoiseSVN 和 TortoiseGit 都是非常优秀的开源的版本库客户端. 分为 32 位版与 64 位版.并且支持各种语言,包括简体中文 下载下载地址：https://tortoisegit.org/download/ 安装我们需要先安装程序包,然后安装语言包(LanguagePack). 因为TortoiseGit 只是一个程序壳,必须依赖一个 Git Core,也就是上一节我们安装的 Git. 所以安装前请确定已完成上一节的操作. 下面以64位版本为演示(64,32位除文件名不一样,其他的操作都一致) 双击安装程序 下一步,进入版权信息界面. 直接点击下一步(Next)即可 下一步,选择SSH客户端. 可以选择 TortoiseGitPlink(位于TortoiseGit安装目录/bin 下), 也可以选择 Git 默认的SSH客户端,位于 Git安装目录/bin/ssh.exe(如果配置了 Path,那直接是 ssh.exe) 接着是选择安装目录,可以保持默认,或者安装到开发环境目录下,安装的程序组件保持默认即可 下一步到确认安装界面,点击 Install按钮安装即可,如下图所示 安装完成,点击 Finish 按钮即可 安装语言包双击打开语言包安装程序 点击下一步(Alt+N), 语言包会自动安装完成 配置在空白处点击鼠标右键, 选择 –&gt; TortoiseGit –&gt; Settings, 然后就可以看到配置界面 选中General,在右边的 Language中选择中文. 不勾选自动升级的复选框,可能还需要指定 Git.exe 文件的路径 再次点击鼠标右键,可以看到弹出菜单中已经变成中文. 原来的 Settings 变成 设置; Clone 变为 克隆]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
